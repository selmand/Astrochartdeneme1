<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Natal Chart Demo - Tek Dosya</title>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tz-lookup@6.1.0/tz.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap');
        body { font-family: 'Roboto', sans-serif; background: #0f172a; color: #e2e8f0; margin:0; padding:20px; }
        .container { display: flex; max-width: 1400px; margin: auto; gap: 30px; flex-wrap: wrap; }
        .form-panel { background: #1e2937; padding: 25px; border-radius: 16px; width: 380px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
        .result-panel { flex: 1; min-width: 700px; }
        h1 { text-align: center; color: #60a5fa; margin-bottom: 10px; }
        .input-group { margin-bottom: 18px; }
        label { display: block; margin-bottom: 6px; font-size: 0.95rem; color: #94a3b8; }
        input, select { width: 100%; padding: 12px; border-radius: 8px; border: none; background: #334155; color: #e2e8f0; font-size: 1rem; }
        input[type="date"], input[type="time"] { padding: 10px; }
        .location-results { max-height: 200px; overflow-y: auto; background: #1e2937; border-radius: 8px; margin-top: 5px; }
        .location-item { padding: 10px; cursor: pointer; border-bottom: 1px solid #334155; }
        .location-item:hover { background: #475569; }
        button { background: #3b82f6; color: white; border: none; padding: 14px 28px; border-radius: 8px; font-size: 1.1rem; cursor: pointer; width: 100%; margin-top: 10px; }
        button:hover { background: #2563eb; }
        .chart-container { background: #1e2937; padding: 25px; border-radius: 16px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.4); margin-bottom: 25px; }
        svg { max-width: 100%; height: auto; background: #0f172a; border-radius: 50%; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; background: #1e2937; border-radius: 12px; overflow: hidden; }
        th, td { padding: 12px; text-align: center; border-bottom: 1px solid #334155; }
        th { background: #334155; color: #60a5fa; }
        .aspect-matrix td { font-size: 1.4rem; width: 60px; height: 60px; }
        .info { font-size: 0.9rem; color: #94a3b8; margin-top: 15px; }
        .error { color: #f87171; background: #450a0a; padding: 10px; border-radius: 8px; display: none; }
        .planet-glyph { font-size: 1.8rem; }
    </style>
</head>
<body>
    <h1>üåå Natal Chart Demo (Swiss Ephemeris WASM)</h1>
    <div class="container">
        <!-- FORM -->
        <div class="form-panel">
            <div class="input-group">
                <label>Tarih (G√ºn/Ay/Yƒ±l)</label>
                <input type="date" id="birthDate" value="1981-08-17">
            </div>
            <div class="input-group">
                <label>Saat (24 saat)</label>
                <input type="time" id="birthTime" value="02:32">
            </div>
            <div class="input-group">
                <label>Lokasyon Ara (≈üehir, √ºlke)</label>
                <input type="text" id="locationSearch" placeholder="Ankara, T√ºrkiye" autocomplete="off">
                <div id="locationResults" class="location-results"></div>
            </div>
            <div class="input-group">
                <label>Se√ßili Lokasyon</label>
                <div style="background:#334155;padding:12px;border-radius:8px;font-size:0.95rem;" id="selectedLocation">Ankara, T√ºrkiye</div>
            </div>
            <div class="input-group">
                <label>Enlem / Boylam</label>
                <input type="text" id="latLon" readonly style="background:#1e2937;color:#64748b;" value="39.9208¬∞ / 32.8541¬∞">
            </div>
            <div class="input-group">
                <label>Timezone (IANA)</label>
                <select id="timezoneSelect"></select>
            </div>
            <div id="errorMsg" class="error"></div>
            <button onclick="calculateChart()">Hesapla & √áiz</button>
            <div class="info">Otomatik hesapla aktif (debounce 600ms). ƒ∞nternet gerekli (Nominatim + WASM CDN).</div>
        </div>

        <!-- RESULTS -->
        <div class="result-panel">
            <div class="chart-container">
                <svg id="natalChart" width="620" height="620" viewBox="0 0 620 620"></svg>
            </div>

            <div style="display:flex;gap:20px;flex-wrap:wrap;">
                <!-- Gezegenler -->
                <div style="flex:1;">
                    <h2 style="color:#60a5fa;margin-bottom:10px;">Gezegenler</h2>
                    <table id="planetsTable">
                        <thead><tr><th>Gezegen</th><th>Bur√ß</th><th>Derece</th><th>Retro</th><th>Ev</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>

                <!-- Evler -->
                <div style="flex:1;">
                    <h2 style="color:#60a5fa;margin-bottom:10px;">Evler (Placidus)</h2>
                    <table id="housesTable">
                        <thead><tr><th>Ev</th><th>Bur√ß</th><th>Derece</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <h2 style="color:#60a5fa;margin:30px 0 10px;">Maj√∂r A√ßƒ±lar</h2>
            <table id="aspectsTable" style="width:100%;">
                <thead><tr><th>A</th><th>B</th><th>A√ßƒ±</th><th>Orb</th></tr></thead>
                <tbody></tbody>
            </table>

            <h2 style="color:#60a5fa;margin:30px 0 10px;">A√ßƒ± Matrisi</h2>
            <table id="aspectMatrix" class="aspect-matrix"></table>
        </div>
    </div>

    <script type="module">
        import SwissEph from 'https://cdn.jsdelivr.net/gh/prolaxu/swisseph-wasm@main/src/swisseph.js';

        const { DateTime } = luxon;
        let sweInstance = null;
        let currentPositions = [];
        let currentCusps = [];
        let currentAspects = [];
        let selectedLat = 39.9208;
        let selectedLon = 32.8541;
        let selectedTz = "Europe/Istanbul";
        let selectedDisplayName = "Ankara, T√ºrkiye";
        let debounceTimer = null;

        // Sabitler
        const PLANETS = [
            { name: "G√ºne≈ü", id: 0, glyph: "‚òâ" },
            { name: "Ay", id: 1, glyph: "‚òΩ" },
            { name: "Merk√ºr", id: 2, glyph: "‚òø" },
            { name: "Ven√ºs", id: 3, glyph: "‚ôÄ" },
            { name: "Mars", id: 4, glyph: "‚ôÇ" },
            { name: "J√ºpiter", id: 5, glyph: "‚ôÉ" },
            { name: "Sat√ºrn", id: 6, glyph: "‚ôÑ" },
            { name: "Uran√ºs", id: 7, glyph: "‚ôÖ" },
            { name: "Nept√ºn", id: 8, glyph: "‚ôÜ" },
            { name: "Pl√ºton", id: 9, glyph: "‚ôá" },
            { name: "Kuzey D√ºƒü√ºm", id: 11, glyph: "‚òä" },
            { name: "Chiron", id: 15, glyph: "‚ö∑" }
        ];

        const SIGN_NAMES = ["Ko√ß", "Boƒüa", "ƒ∞kizler", "Yenge√ß", "Aslan", "Ba≈üak", "Terazi", "Akrep", "Yay", "Oƒülak", "Kova", "Balƒ±k"];
        const SIGN_GLYPHS = ["‚ôà","‚ôâ","‚ôä","‚ôã","‚ôå","‚ôç","‚ôé","‚ôè","‚ôê","‚ôë","‚ôí","‚ôì"];

        const ASPECTS_DEF = [
            { angle: 0, orb: 8, name: "Kavu≈üum", sym: "‚òå", color: "#ef4444" },
            { angle: 60, orb: 6, name: "Sextil", sym: "‚öπ", color: "#22c55e" },
            { angle: 90, orb: 6, name: "Kare", sym: "‚ñ°", color: "#ef4444" },
            { angle: 120, orb: 6, name: "√ú√ßgen", sym: "‚ñ≥", color: "#3b82f6" },
            { angle: 180, orb: 8, name: "Kar≈üƒ±t", sym: "‚òç", color: "#ef4444" }
        ];

        const COMMON_TZ = [
            "Europe/Istanbul","Europe/London","Europe/Paris","Europe/Berlin","Europe/Moscow",
            "America/New_York","America/Chicago","America/Los_Angeles","America/Sao_Paulo",
            "Asia/Tokyo","Asia/Shanghai","Asia/Dubai","Australia/Sydney","Pacific/Auckland"
        ];

        async function initSwissEph() {
            if (sweInstance) return sweInstance;
            sweInstance = new SwissEph();
            await sweInstance.initSwissEph();
            console.log("%cSwiss Ephemeris WASM y√ºklendi", "color:#22c55e;font-weight:bold");
            return sweInstance;
        }

        function degToDMS(deg) {
            const d = Math.floor(deg);
            const m = Math.floor((deg - d) * 60);
            const s = Math.round(((deg - d) * 60 - m) * 60);
            return `${d}¬∞${m.toString().padStart(2,'0')}'${s.toString().padStart(2,'0')}"`;
        }

        function lngToSign(lng) {
            const norm = ((lng % 360) + 360) % 360;
            const idx = Math.floor(norm / 30);
            const degInSign = norm % 30;
            return {
                signIdx: idx,
                sign: SIGN_NAMES[idx],
                glyph: SIGN_GLYPHS[idx],
                dms: degToDMS(degInSign)
            };
        }

        async function calculatePositions(jd, lat, lon) {
            const swe = await initSwissEph();
            const positions = [];

            for (const p of PLANETS) {
                const flag = swe.SEFLG_SWIEPH | swe.SEFLG_SPEED;
                const res = swe.calc_ut(jd, p.id, flag);
                if (res.length < 4) continue;
                let lng = ((res[0] % 360) + 360) % 360;
                const speed = res[3];
                positions.push({
                    ...p,
                    lng: lng,
                    speed: speed,
                    retro: speed < -0.01,
                    signInfo: lngToSign(lng)
                });
            }
            return positions;
        }

        function calculateHouses(RAMC, lat, obliquity) {
            const e = obliquity || 23.44;
            const f = lat;

            function iterateRa(initialRa, fFactor, isUpper) {
                let ra = initialRa;
                for (let iter = 0; iter < 10; iter++) {
                    const sinRa = Math.sin(degToRad(ra));
                    let arg = sinRa * Math.tan(degToRad(e)) * Math.tan(degToRad(f));
                    arg = Math.max(Math.min(arg, 1), -1);
                    let arc;
                    if (isUpper) {
                        arc = radToDeg(Math.acos(arg)) / fFactor;
                        ra = (RAMC + 180 - arc) % 360;
                    } else {
                        arc = radToDeg(Math.acos(-arg)) / fFactor;
                        ra = (RAMC + arc) % 360;
                    }
                }
                return ra;
            }

            function raToC(ra) {
                const sinRa = Math.sin(degToRad(ra));
                const cosRa = Math.cos(degToRad(ra));
                let c = radToDeg(Math.atan(sinRa / (Math.cos(degToRad(e)) * cosRa)));
                if (cosRa < 0) c += 180;
                if (c < 0) c += 360;
                return c % 360;
            }

            const ra11 = iterateRa(RAMC + 30, 3, false);
            const c11 = raToC(ra11);

            const ra12 = iterateRa(RAMC + 60, 1.5, false);
            const c12 = raToC(ra12);

            const ra2 = iterateRa(RAMC + 120, 1.5, true);
            const c2 = raToC(ra2);

            const ra3 = iterateRa(RAMC + 150, 3, true);
            const c3 = raToC(ra3);

            let mc = radToDeg(Math.atan(Math.tan(degToRad(RAMC)) / Math.cos(degToRad(e))));
            if (mc < 0) mc += 180;
            if (RAMC > 180) mc += 180;
            mc = mc % 360;

            const sinRamc = Math.sin(degToRad(RAMC));
            const cosRamc = Math.cos(degToRad(RAMC));
            let asc = radToDeg(Math.atan2(-cosRamc, sinRamc * Math.cos(degToRad(e)) + Math.tan(degToRad(f)) * Math.sin(degToRad(e))));
            if (asc < 0) asc += 360;
            asc = asc % 360;

            const cusps = [0, asc, c2, c3, (mc + 180) % 360, (c11 + 180) % 360, (c12 + 180) % 360, (asc + 180) % 360, (c2 + 180) % 360, (c3 + 180) % 360, mc, c11, c12];

            return cusps;
        }

        function degToRad(deg) {
            return deg * Math.PI / 180;
        }

        function radToDeg(rad) {
            return rad * 180 / Math.PI;
        }

        function findHouseForPlanet(lng, cusps) {
            const p = ((lng % 360) + 360) % 360;
            for (let i = 1; i <= 12; i++) {
                let c1 = ((cusps[i] % 360) + 360) % 360;
                let c2 = ((cusps[i === 12 ? 1 : i + 1] % 360) + 360) % 360;
                if (c2 < c1) c2 += 360;
                let pp = p;
                if (pp < c1) pp += 360;
                if (pp >= c1 && pp < c2) return i;
            }
            return 1;
        }

        function calculateAspects(positions) {
            const aspects = [];
            for (let i = 0; i < positions.length; i++) {
                for (let j = i + 1; j < positions.length; j++) {
                    let diff = Math.abs(positions[i].lng - positions[j].lng);
                    diff = Math.min(diff, 360 - diff);
                    for (const asp of ASPECTS_DEF) {
                        const orbVal = Math.abs(diff - asp.angle);
                        const maxOrb = (positions[i].id === 0 || positions[j].id === 0 || positions[i].id === 1 || positions[j].id === 1) ? 8 : 6;
                        if (orbVal <= maxOrb) {
                            aspects.push({
                                p1: positions[i],
                                p2: positions[j],
                                aspect: asp,
                                orb: orbVal.toFixed(2)
                            });
                        }
                    }
                }
            }
            return aspects;
        }

        function createSVGChart(positions, cusps) {
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "620");
            svg.setAttribute("height", "620");
            svg.setAttribute("viewBox", "0 0 620 620");

            const cx = 310, cy = 310;
            const rOuter = 295, rSign = 260, rHouse = 225, rPlanet = 180, rInner = 70;

            // Arka plan halkasƒ±
            const bg = document.createElementNS(svgNS, "circle");
            bg.setAttribute("cx", cx); bg.setAttribute("cy", cy); bg.setAttribute("r", rOuter);
            bg.setAttribute("fill", "#1e2937"); bg.setAttribute("stroke", "#475569"); bg.setAttribute("stroke-width", "40");
            svg.appendChild(bg);

            // 12 Bur√ß dilimi
            for (let i = 0; i < 12; i++) {
                const a1 = (i * 30 - 90) * Math.PI / 180;
                const a2 = ((i + 1) * 30 - 90) * Math.PI / 180;
                const x1 = cx + rSign * Math.cos(a1);
                const y1 = cy + rSign * Math.sin(a1);
                const x2 = cx + rSign * Math.cos(a2);
                const y2 = cy + rSign * Math.sin(a2);
                const path = document.createElementNS(svgNS, "path");
                path.setAttribute("d", `M ${cx},${cy} L ${x1},${y1} A ${rSign},${rSign} 0 0 1 ${x2},${y2} Z`);
                path.setAttribute("fill", i % 2 === 0 ? "#334155" : "#1e2937");
                path.setAttribute("stroke", "#64748b");
                svg.appendChild(path);

                // Bur√ß glif
                const midA = (i * 30 + 15 - 90) * Math.PI / 180;
                const tx = cx + (rSign + 22) * Math.cos(midA);
                const ty = cy + (rSign + 22) * Math.sin(midA);
                const text = document.createElementNS(svgNS, "text");
                text.setAttribute("x", tx); text.setAttribute("y", ty);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("dominant-baseline", "middle");
                text.setAttribute("fill", "#f1f5f9");
                text.setAttribute("font-size", "22");
                text.setAttribute("transform", `rotate(${i*30 + 15 - 90 + 90}, ${tx}, ${ty})`);
                text.textContent = SIGN_GLYPHS[i];
                svg.appendChild(text);
            }

            // Ev √ßizgileri (Placidus)
            const houseCuspsNorm = cusps.slice(1, 13).map(c => ((c % 360) + 360) % 360);
            for (let i = 0; i < 12; i++) {
                const ang = (houseCuspsNorm[i] - 90) * Math.PI / 180;
                const x1 = cx + rHouse * Math.cos(ang);
                const y1 = cy + rHouse * Math.sin(ang);
                const x2 = cx + (rOuter - 20) * Math.cos(ang);
                const y2 = cy + (rOuter - 20) * Math.sin(ang);
                const line = document.createElementNS(svgNS, "line");
                line.setAttribute("x1", x1); line.setAttribute("y1", y1);
                line.setAttribute("x2", x2); line.setAttribute("y2", y2);
                line.setAttribute("stroke", "#94a3b8");
                line.setAttribute("stroke-width", "2");
                svg.appendChild(line);
            }

            // ASC & MC i≈üaretleri
            const ascAng = (houseCuspsNorm[0] - 90) * Math.PI / 180; // cusp 1 = ASC
            const mcAng = (houseCuspsNorm[9] - 90) * Math.PI / 180;  // cusp 10 = MC
            const ascX = cx + (rOuter - 35) * Math.cos(ascAng);
            const ascY = cy + (rOuter - 35) * Math.sin(ascAng);
            const ascTxt = document.createElementNS(svgNS, "text");
            ascTxt.setAttribute("x", ascX); ascTxt.setAttribute("y", ascY);
            ascTxt.setAttribute("fill", "#eab308"); ascTxt.setAttribute("font-size", "18"); ascTxt.setAttribute("font-weight", "bold");
            ascTxt.textContent = "ASC";
            svg.appendChild(ascTxt);

            const mcX = cx + (rOuter - 35) * Math.cos(mcAng);
            const mcY = cy + (rOuter - 35) * Math.sin(mcAng);
            const mcTxt = document.createElementNS(svgNS, "text");
            mcTxt.setAttribute("x", mcX); mcTxt.setAttribute("y", mcY);
            mcTxt.setAttribute("fill", "#eab308"); mcTxt.setAttribute("font-size", "18"); mcTxt.setAttribute("font-weight", "bold");
            mcTxt.textContent = "MC";
            svg.appendChild(mcTxt);

            // Gezegenler
            const placed = [];
            positions.forEach((p, idx) => {
                let ang = (p.lng - 90) * Math.PI / 180;
                let radius = rPlanet;
                // Basit collision offset
                let tries = 0;
                while (placed.some(pl => Math.abs(pl.ang - ang) < 0.15) && tries < 8) {
                    ang += 0.12;
                    tries++;
                }
                placed.push({ang});

                const px = cx + radius * Math.cos(ang);
                const py = cy + radius * Math.sin(ang);

                // Glif
                const g = document.createElementNS(svgNS, "g");
                const circ = document.createElementNS(svgNS, "circle");
                circ.setAttribute("cx", px); circ.setAttribute("cy", py);
                circ.setAttribute("r", "18"); circ.setAttribute("fill", "#1e2937");
                circ.setAttribute("stroke", "#60a5fa"); circ.setAttribute("stroke-width", "3");
                g.appendChild(circ);

                const txt = document.createElementNS(svgNS, "text");
                txt.setAttribute("x", px); txt.setAttribute("y", py + 7);
                txt.setAttribute("text-anchor", "middle");
                txt.setAttribute("fill", "#f1f5f9");
                txt.setAttribute("font-size", "26");
                txt.textContent = p.glyph;
                g.appendChild(txt);

                // Retro
                if (p.retro) {
                    const rtxt = document.createElementNS(svgNS, "text");
                    rtxt.setAttribute("x", px + 22); rtxt.setAttribute("y", py - 18);
                    rtxt.setAttribute("fill", "#f59e0b"); rtxt.setAttribute("font-size", "14");
                    rtxt.textContent = "R";
                    g.appendChild(rtxt);
                }

                svg.appendChild(g);
            });

            // A√ßƒ±lar (merkezde)
            const aspectLines = calculateAspects(positions);
            aspectLines.forEach(a => {
                const a1 = (a.p1.lng - 90) * Math.PI / 180;
                const a2 = (a.p2.lng - 90) * Math.PI / 180;
                const x1 = cx + (rPlanet - 25) * Math.cos(a1);
                const y1 = cy + (rPlanet - 25) * Math.sin(a1);
                const x2 = cx + (rPlanet - 25) * Math.cos(a2);
                const y2 = cy + (rPlanet - 25) * Math.sin(a2);

                const line = document.createElementNS(svgNS, "line");
                line.setAttribute("x1", x1); line.setAttribute("y1", y1);
                line.setAttribute("x2", x2); line.setAttribute("y2", y2);
                line.setAttribute("stroke", a.aspect.color);
                line.setAttribute("stroke-width", "1.5");
                line.setAttribute("stroke-opacity", "0.75");
                svg.appendChild(line);
            });

            // ƒ∞√ß halka
            const inner = document.createElementNS(svgNS, "circle");
            inner.setAttribute("cx", cx); inner.setAttribute("cy", cy); inner.setAttribute("r", rInner);
            inner.setAttribute("fill", "none"); inner.setAttribute("stroke", "#475569"); inner.setAttribute("stroke-width", "12");
            svg.appendChild(inner);

            return svg;
        }

        function renderTables(positions, cusps, aspects) {
            // Gezegenler tablosu
            const ptbody = document.querySelector("#planetsTable tbody");
            ptbody.innerHTML = "";
            positions.forEach(p => {
                const house = findHouseForPlanet(p.lng, cusps);
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td><span class="planet-glyph">${p.glyph}</span> ${p.name}</td>
                    <td>${p.signInfo.glyph} ${p.signInfo.sign}</td>
                    <td>${p.signInfo.dms}</td>
                    <td style="color:${p.retro?'#f59e0b':'#64748b'}">${p.retro ? 'R' : ''}</td>
                    <td>${house}</td>
                `;
                ptbody.appendChild(tr);
            });

            // Evler tablosu
            const htbody = document.querySelector("#housesTable tbody");
            htbody.innerHTML = "";
            for (let i = 1; i <= 12; i++) {
                const c = cusps[i];
                const s = lngToSign(c);
                const tr = document.createElement("tr");
                tr.innerHTML = `<td><b>${i}</b></td><td>${s.glyph} ${s.sign}</td><td>${s.dms}</td>`;
                htbody.appendChild(tr);
            };

            // A√ßƒ±lar tablosu
            const atbody = document.querySelector("#aspectsTable tbody");
            atbody.innerHTML = "";
            aspects.forEach(a => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${a.p1.glyph} ${a.p1.name}</td>
                    <td>${a.p2.glyph} ${a.p2.name}</td>
                    <td style="color:${a.aspect.color}">${a.aspect.sym} ${a.aspect.name}</td>
                    <td>${a.orb}¬∞</td>
                `;
                atbody.appendChild(tr);
            });

            // A√ßƒ± matrisi
            const matrixPlanets = positions.slice(0, 11); // Sun..Pluto + Node
            const matrix = document.getElementById("aspectMatrix");
            matrix.innerHTML = `<thead><tr><th></th>${matrixPlanets.map(p => `<th>${p.glyph}</th>`).join('')}</tr></thead><tbody></tbody>`;
            const mtbody = matrix.querySelector("tbody");

            matrixPlanets.forEach((p1, i) => {
                const row = document.createElement("tr");
                row.innerHTML = `<td style="font-weight:500">${p1.glyph}</td>`;
                matrixPlanets.forEach((p2, j) => {
                    if (i === j) {
                        row.innerHTML += `<td style="background:#334155">‚Äî</td>`;
                        return;
                    }
                    let diff = Math.abs(p1.lng - p2.lng);
                    diff = Math.min(diff, 360 - diff);
                    let found = null;
                    for (const asp of ASPECTS_DEF) {
                        if (Math.abs(diff - asp.angle) <= (i<2||j<2?8:6)) {
                            found = asp;
                            break;
                        }
                    }
                    if (found) {
                        row.innerHTML += `<td style="color:${found.color}">${found.sym}<br><span style="font-size:0.7rem">${(Math.abs(diff-found.angle)).toFixed(1)}</span></td>`;
                    } else {
                        row.innerHTML += `<td></td>`;
                    }
                });
                mtbody.appendChild(row);
            });
        }

        function julianDay(year, month, day, hour) {
            if (month <= 2) {
                year--;
                month += 12;
            }
            const a = Math.floor(year / 100);
            const b = 2 - a + Math.floor(a / 4);
            return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + b - 1524.5 + hour / 24;
        }

        function gmst(jd) {
            const d0 = jd - 2451545.0;
            const h = (jd - Math.floor(jd) - 0.5) * 24;
            const t = d0 / 36525.0;
            let gmst = 6.697374558 + 0.06570982441908 * d0 + 1.00273790935 * h + 0.000026 * t * t;
            gmst = gmst % 24;
            return gmst;
        }

        async function getUTCFromLocal(year, month, day, hour, minute, tz) {
            const dt = DateTime.fromObject({
                year, month, day, hour, minute, second: 0
            }, { zone: tz });
            if (dt.invalid) throw new Error("Ge√ßersiz tarih/saat (DST sorunu?)");
            return {
                year: dt.toUTC().year,
                month: dt.toUTC().month,
                day: dt.toUTC().day,
                hour: dt.toUTC().hour + dt.toUTC().minute / 60
            };
        }

        async function calculateChart() {
            const errorEl = document.getElementById("errorMsg");
            errorEl.style.display = "none";

            try {
                const dateVal = document.getElementById("birthDate").value;
                const timeVal = document.getElementById("birthTime").value;
                if (!dateVal || !timeVal) throw new Error("Tarih ve saat girin");

                const [year, month, day] = dateVal.split('-').map(Number);
                const [hour, minute] = timeVal.split(':').map(Number);
                const tz = document.getElementById("timezoneSelect").value || selectedTz;

                const utcData = await getUTCFromLocal(year, month, day, hour, minute, tz);
                const swe = await initSwissEph();
                const jd = swe.julday(utcData.year, utcData.month, utcData.day, utcData.hour, 1);

                const positions = await calculatePositions(jd, selectedLat, selectedLon);
                const gmstHour = gmst(jd);
                const lstHour = (gmstHour + selectedLon / 15) % 24;
                const ramc = lstHour * 15;

                const cusps = calculateHouses(ramc, selectedLat);

                const aspects = calculateAspects(positions);

                // SVG
                const svgContainer = document.getElementById("natalChart");
                svgContainer.innerHTML = "";
                const newSVG = createSVGChart(positions, cusps);
                svgContainer.appendChild(newSVG);

                // Tablolar
                renderTables(positions, cusps, aspects);

                // Global sakla
                currentPositions = positions;
                currentCusps = cusps;
                currentAspects = aspects;

            } catch (e) {
                console.error(e);
                errorEl.textContent = e.message || "Hesaplama hatasƒ± (WASM import hatasƒ± olursa ekrana ve console‚Äôa net hata yaz.";
                errorEl.style.display = "block";
            }
        }

        async function searchNominatim(query) {
            if (query.length < 3) return [];
            const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=8&addressdetails=1&accept-language=tr`;
            const res = await fetch(url, {
                headers: { 'User-Agent': 'NatalChartDemo/1.0 (https://github.com)' }
            });
            const data = await res.json();
            return data;
        }

        function debounceSearch() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(async () => {
                const q = document.getElementById("locationSearch").value.trim();
                const resultsDiv = document.getElementById("locationResults");
                resultsDiv.innerHTML = "";
                if (q.length < 3) return;
                const places = await searchNominatim(q);
                places.forEach(place => {
                    const lat = parseFloat(place.lat);
                    const lon = parseFloat(place.lon);
                    const name = place.display_name || `${place.name}, ${place.address?.country || ''}`;
                    const div = document.createElement("div");
                    div.className = "location-item";
                    div.textContent = name;
                    div.onclick = () => {
                        selectedLat = lat;
                        selectedLon = lon;
                        selectedDisplayName = name;
                        selectedTz = tzlookup(lat, lon) || "UTC";
                        document.getElementById("selectedLocation").textContent = name;
                        document.getElementById("latLon").value = `${lat.toFixed(4)}¬∞ / ${lon.toFixed(4)}¬∞`;
                        const tzSel = document.getElementById("timezoneSelect");
                        if (!Array.from(tzSel.options).some(opt => opt.value === selectedTz)) {
                            const opt = document.createElement("option");
                            opt.value = selectedTz; opt.textContent = selectedTz;
                            tzSel.appendChild(opt);
                        }
                        tzSel.value = selectedTz;
                        resultsDiv.innerHTML = "";
                        document.getElementById("locationSearch").value = "";
                        calculateChart(); // auto
                    };
                    resultsDiv.appendChild(div);
                });
            }, 420);
        }

        // Auto debounce calculate
        function setupAutoCalculate() {
            const inputs = ["birthDate","birthTime","timezoneSelect"];
            inputs.forEach(id => {
                const el = document.getElementById(id);
                el.addEventListener("change", () => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(calculateChart, 600);
                });
            });
            document.getElementById("locationSearch").addEventListener("input", debounceSearch);
        }

        // Init UI
        async function initUI() {
            const tzSel = document.getElementById("timezoneSelect");
            COMMON_TZ.forEach(tz => {
                const opt = document.createElement("option");
                opt.value = tz; opt.textContent = tz;
                tzSel.appendChild(opt);
            });
            tzSel.value = "Europe/Istanbul";

            // Default location
            document.getElementById("selectedLocation").textContent = selectedDisplayName;
            document.getElementById("latLon").value = `${selectedLat.toFixed(4)}¬∞ / ${selectedLon.toFixed(4)}¬∞`;

            // ƒ∞lk y√ºkle
            await initSwissEph();
            setupAutoCalculate();
            calculateChart(); // initial
        }

        // Ba≈ülat
        window.onload = initUI;

        // Global eri≈üim (debug)
        window.calculateChart = calculateChart;
    </script>
</body>
</html>
```            }

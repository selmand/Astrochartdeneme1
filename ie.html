<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Natal Chart Demo (Browser Only)</title>
  <style>
    :root { --fg:#111; --muted:#666; --bg:#fff; --line:#ddd; --soft:#f7f7f7; --err:#b00020; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: var(--fg); background: var(--bg); }
    header { padding: 14px 16px; border-bottom: 1px solid var(--line); background: var(--soft); }
    header h1 { margin: 0; font-size: 16px; font-weight: 800; }
    header .note { margin-top: 6px; color: var(--muted); font-size: 12px; }
    main { padding: 16px; display: grid; gap: 14px; grid-template-columns: 380px 1fr; align-items: start; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .card { border: 1px solid var(--line); border-radius: 10px; overflow: hidden; }
    .card .hd { padding: 10px 12px; font-weight: 800; background: var(--soft); border-bottom: 1px solid var(--line); }
    .card .bd { padding: 12px; }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid .full { grid-column: 1 / -1; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    input, select, button {
      width: 100%; box-sizing: border-box; padding: 9px 10px; border: 1px solid var(--line);
      border-radius: 8px; font-size: 14px; background: #fff;
    }
    input[readonly] { background: #fafafa; color: #333; }
    button { cursor: pointer; font-weight: 800; }
    .tiny { font-size: 12px; color: var(--muted); }
    .warn { color: #8a5a00; background: #fff7e6; border: 1px solid #ffd27d; padding: 10px; border-radius: 10px; }
    .error { color: #fff; background: var(--err); padding: 10px; border-radius: 10px; }
    .ok { color: #0a6; background: #eafff2; border: 1px solid #b5f0cf; padding: 10px; border-radius: 10px; }
    .pill { display: inline-block; padding: 3px 8px; border-radius: 999px; border: 1px solid var(--line); background: #fff; font-size: 12px; color: var(--muted); }

    .autocomplete { position: relative; }
    .results {
      position: absolute; z-index: 20; left: 0; right: 0; top: calc(100% + 6px);
      border: 1px solid var(--line); border-radius: 10px; background: #fff; overflow: hidden;
      box-shadow: 0 12px 30px rgba(0,0,0,.08);
      max-height: 260px; overflow-y: auto;
    }
    .results button {
      width: 100%; text-align: left; border: 0; border-bottom: 1px solid #eee;
      padding: 10px 12px; background: #fff; border-radius: 0; font-weight: 700;
    }
    .results button:hover { background: #f6f6f6; }
    .results button:last-child { border-bottom: 0; }

    .split { display: grid; grid-template-columns: 520px 1fr; gap: 14px; }
    @media (max-width: 1200px) { .split { grid-template-columns: 1fr; } }

    .svgWrap { display: grid; place-items: center; padding: 12px; }
    svg { max-width: 100%; height: auto; }
    .tables { display: grid; gap: 14px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { border: 1px solid var(--line); padding: 6px 8px; vertical-align: top; }
    th { background: var(--soft); text-align: left; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .center { text-align: center; }
    .muted { color: var(--muted); }
    .small { font-size: 12px; }
    .aspectCell { white-space: nowrap; text-align: center; }
    .footerline { margin-top: 8px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>Natal Chart Demo (tek dosya, sadece tarayıcı)</h1>
    <div class="note">Nasıl çalıştırılır: Bu dosyayı <span class="mono">index.html</span> olarak kaydet, GitHub Pages/HTTP üzerinden aç. İnternet şart (CDN + Nominatim + WASM). Backend yok.</div>
  </header>

  <main>
    <section class="card">
      <div class="hd">Girdi</div>
      <div class="bd">
        <div id="statusBox" class="tiny"></div>

        <div class="grid" style="margin-top:10px;">
          <div>
            <label>Tarih</label>
            <input id="dateInput" type="date" />
            <div class="tiny" id="datePretty"></div>
          </div>
          <div>
            <label>Saat (24 saat)</label>
            <input id="timeInput" type="time" step="60" />
          </div>

          <div class="full autocomplete">
            <label>Lokasyon (şehir/ülke ara)</label>
            <input id="locInput" placeholder="Ankara, Türkiye" autocomplete="off" />
            <div id="locResults" class="results" style="display:none;"></div>
            <div class="tiny" style="margin-top:6px;">Geocoding: Nominatim (OpenStreetMap) • min 3 karakter • debounce + cache</div>
          </div>

          <div>
            <label>Enlem (lat)</label>
            <input id="latInput" readonly />
          </div>
          <div>
            <label>Boylam (lon)</label>
            <input id="lonInput" readonly />
          </div>

          <div class="full">
            <label>Timezone (IANA)</label>
            <select id="tzSelect"></select>
            <div class="tiny" style="margin-top:6px;">Lokasyondan otomatik (tz-lookup). İstersen elle değiştir.</div>
          </div>

          <div class="full" id="dstBox" style="display:none;"></div>

          <div class="full">
            <button id="calcBtn">Hesapla</button>
            <div class="tiny" style="margin-top:8px;">
              Ev sistemi: <span class="pill">Placidus</span>
              <span style="margin-left:10px" class="muted">Otomatik güncelleme: input değişince debounce ile yeniden hesaplar.</span>
            </div>
          </div>

          <div class="full">
            <div class="card" style="border-radius:10px;">
              <div class="hd">Seçilen Lokasyon Özeti</div>
              <div class="bd">
                <div class="small"><span class="muted">Ad:</span> <span id="locName">—</span></div>
                <div class="small"><span class="muted">Lat/Lon:</span> <span id="locLatLon">—</span></div>
                <div class="small"><span class="muted">Timezone:</span> <span id="locTz">—</span></div>
                <div class="small"><span class="muted">Local → UTC:</span> <span id="locUtc">—</span></div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </section>

    <section class="card">
      <div class="hd">Çıktı</div>
      <div class="bd">
        <div class="split">
          <div class="card">
            <div class="hd">Natal Chart Wheel (SVG)</div>
            <div class="bd svgWrap">
              <div id="chartWrap"></div>
              <div class="footerline">Gezegenler iç halka • Ev çizgileri Placidus cusp • ASC/DSC/MC/IC etiketli • Aspekt çizgileri merkezde</div>
            </div>
          </div>

          <div class="tables">
            <div class="card">
              <div class="hd">Gezegen / Nokta Konumları</div>
              <div class="bd">
                <div class="tiny" id="engineInfo"></div>
                <div style="overflow:auto; margin-top:8px;">
                  <table id="planetTable">
                    <thead>
                      <tr>
                        <th>Body</th>
                        <th>Lon (0–360)</th>
                        <th>Burç</th>
                        <th>Derece</th>
                        <th>R</th>
                        <th class="center">Ev</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Ev Cusp (Placidus)</div>
              <div class="bd" style="overflow:auto;">
                <table id="houseTable">
                  <thead>
                    <tr>
                      <th>Ev</th>
                      <th>Burç</th>
                      <th>Derece</th>
                      <th>Lon (0–360)</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
                <div class="tiny" style="margin-top:6px;">ASC ve MC ayrıca chart üzerinde işaretli.</div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Açı Listesi (Majör)</div>
              <div class="bd" style="overflow:auto;">
                <table id="aspectList">
                  <thead>
                    <tr>
                      <th>Body A</th>
                      <th>Body B</th>
                      <th>Açı</th>
                      <th>Orb</th>
                      <th>Applying/Separating</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
                <div class="tiny" style="margin-top:6px;">Orb: Güneş/Ay 8° • Diğerleri + Node 6°</div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Açı Tablosu (Matrix)</div>
              <div class="bd" style="overflow:auto;">
                <table id="aspectMatrix"></table>
              </div>
            </div>
          </div>
        </div>

      </div>
    </section>
  </main>

  <script type="module">
    const $ = (sel) => document.querySelector(sel);
    const pad2 = (n) => String(n).padStart(2, "0");
    const deg2rad = (d) => (d * Math.PI) / 180;
    const norm360 = (d) => ((d % 360) + 360) % 360;
    const norm180 = (d) => {
      let x = ((d % 360) + 360) % 360;
      if (x > 180) x -= 360;
      return x;
    };
    const fmtDMS = (deg) => {
      const d = norm360(deg);
      const signIndex = Math.floor(d / 30);
      const signDeg = d - signIndex * 30;
      const dd = Math.floor(signDeg);
      const mmFloat = (signDeg - dd) * 60;
      const mm = Math.floor(mmFloat);
      const ss = Math.floor((mmFloat - mm) * 60);
      return { signIndex, dd, mm, ss };
    };
    const orbToText = (orbDeg) => {
      const a = Math.abs(orbDeg);
      const d = Math.floor(a);
      const m = Math.floor((a - d) * 60);
      return `${d}°${pad2(m)}′`;
    };
    const debounce = (fn, wait=350) => {
      let t = null;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
    };
    const isSupportedIana = (tz) => {
      try { new Intl.DateTimeFormat("en-US", { timeZone: tz }).format(new Date()); return true; }
      catch { return false; }
    };

    import tzLookup from "https://cdn.jsdelivr.net/npm/tz-lookup@6.1.25/+esm";
    import SwissEph from "https://cdn.jsdelivr.net/gh/prolaxu/swisseph-wasm@main/src/swisseph.js";

    const SIGNS = [
      { name:"Koç", sym:"♈" }, { name:"Boğa", sym:"♉" }, { name:"İkizler", sym:"♊" }, { name:"Yengeç", sym:"♋" },
      { name:"Aslan", sym:"♌" }, { name:"Başak", sym:"♍" }, { name:"Terazi", sym:"♎" }, { name:"Akrep", sym:"♏" },
      { name:"Yay", sym:"♐" }, { name:"Oğlak", sym:"♑" }, { name:"Kova", sym:"♒" }, { name:"Balık", sym:"♓" }
    ];

    const BODIES = [
      { key:"Sun",    label:"Güneş",     glyph:"☉", idKey:"SE_SUN" },
      { key:"Moon",   label:"Ay",        glyph:"☽", idKey:"SE_MOON" },
      { key:"Mercury",label:"Merkür",    glyph:"☿", idKey:"SE_MERCURY" },
      { key:"Venus",  label:"Venüs",     glyph:"♀", idKey:"SE_VENUS" },
      { key:"Mars",   label:"Mars",      glyph:"♂", idKey:"SE_MARS" },
      { key:"Jupiter",label:"Jüpiter",   glyph:"♃", idKey:"SE_JUPITER" },
      { key:"Saturn", label:"Satürn",    glyph:"♄", idKey:"SE_SATURN" },
      { key:"Uranus", label:"Uranüs",    glyph:"♅", idKey:"SE_URANUS" },
      { key:"Neptune",label:"Neptün",    glyph:"♆", idKey:"SE_NEPTUNE" },
      { key:"Pluto",  label:"Plüton",    glyph:"♇", idKey:"SE_PLUTO" },
      { key:"Node",   label:"True Node", glyph:"☊", idKey:"SE_TRUE_NODE" },
    ];

    const ASPECTS = [
      { name:"Kavuşum", angle:0,   sym:"☌" },
      { name:"Sekstil", angle:60,  sym:"✶" },
      { name:"Kare",    angle:90,  sym:"□" },
      { name:"Üçgen",   angle:120, sym:"△" },
      { name:"Karşıt",  angle:180, sym:"☍" }
    ];

    class NominatimService {
      constructor() { this.cache = new Map(); this.inflight = new Map(); }
      async search(q) {
        const query = (q || "").trim();
        if (query.length < 3) return [];
        const key = query.toLowerCase();
        if (this.cache.has(key)) return this.cache.get(key);
        if (this.inflight.has(key)) return this.inflight.get(key);

        const url = new URL("https://nominatim.openstreetmap.org/search");
        url.searchParams.set("format", "jsonv2");
        url.searchParams.set("addressdetails", "1");
        url.searchParams.set("limit", "7");
        url.searchParams.set("q", query);

        const p = fetch(url.toString(), { headers: { "Accept":"application/json", "Accept-Language":"tr" } })
          .then(r => r.json())
          .then(arr => {
            const cleaned = (arr || []).map(x => ({
              displayName: x.display_name,
              lat: Number(x.lat),
              lon: Number(x.lon)
            }));
            this.cache.set(key, cleaned);
            this.inflight.delete(key);
            return cleaned;
          })
          .catch(err => { this.inflight.delete(key); throw err; });

        this.inflight.set(key, p);
        return p;
      }
    }

    class TimezoneService {
      constructor() { this.tzList = this._build(); }
      _build() {
        let list = [];
        try { if (Intl && typeof Intl.supportedValuesOf === "function") list = Intl.supportedValuesOf("timeZone") || []; } catch {}
        if (!list.length) {
          list = [
            "Europe/Istanbul","Europe/London","Europe/Paris","Europe/Berlin","Europe/Moscow",
            "America/New_York","America/Chicago","America/Denver","America/Los_Angeles",
            "America/Sao_Paulo","Asia/Dubai","Asia/Tehran","Asia/Jerusalem","Asia/Kolkata",
            "Asia/Bangkok","Asia/Singapore","Asia/Shanghai","Asia/Tokyo","Australia/Sydney",
            "Pacific/Auckland","UTC"
          ];
        }
        return list.filter(isSupportedIana);
      }
      lookup(lat, lon) {
        const tz = tzLookup(lat, lon);
        return isSupportedIana(tz) ? tz : null;
      }
    }

    class TimeZoneMath {
      static _dtfCache = new Map();
      static _getDTF(timeZone) {
        const key = `${timeZone}|en-CA`;
        if (this._dtfCache.has(key)) return this._dtfCache.get(key);
        const dtf = new Intl.DateTimeFormat("en-CA", {
          timeZone,
          year: "numeric", month: "2-digit", day: "2-digit",
          hour: "2-digit", minute: "2-digit", second: "2-digit",
          hourCycle: "h23"
        });
        this._dtfCache.set(key, dtf);
        return dtf;
      }

      static _partsToObj(parts) {
        const o = {};
        for (const p of parts) if (p.type !== "literal") o[p.type] = p.value;
        return {
          year: Number(o.year), month: Number(o.month), day: Number(o.day),
          hour: Number(o.hour), minute: Number(o.minute), second: Number(o.second)
        };
      }

      static formatUTCmsInZone(utcMs, timeZone) {
        const dtf = this._getDTF(timeZone);
        const parts = dtf.formatToParts(new Date(utcMs));
        return this._partsToObj(parts);
      }

      static getOffsetMinutes(timeZone, utcMs) {
        const z = this.formatUTCmsInZone(utcMs, timeZone);
        const localAsUTC = Date.UTC(z.year, z.month - 1, z.day, z.hour, z.minute, z.second);
        return (localAsUTC - utcMs) / 60000;
      }

      static _matchesLocal(utcMs, timeZone, y, m, d, hh, mm) {
        const z = this.formatUTCmsInZone(utcMs, timeZone);
        return z.year === y && z.month === m && z.day === d && z.hour === hh && z.minute === mm;
      }

      static localToUtcCandidates(timeZone, y, m, d, hh, mm) {
        if (!isSupportedIana(timeZone)) throw new Error(`Timezone desteklenmiyor: ${timeZone}`);
        const naiveUTC = Date.UTC(y, m - 1, d, hh, mm, 0);

        const samples = [
          naiveUTC - 36*3600*1000, naiveUTC - 6*3600*1000, naiveUTC,
          naiveUTC + 6*3600*1000,  naiveUTC + 36*3600*1000
        ];
        const offsets = new Set(samples.map(ms => this.getOffsetMinutes(timeZone, ms)));

        {
          let guess = naiveUTC;
          for (let i=0;i<4;i++) {
            const off = this.getOffsetMinutes(timeZone, guess);
            const cand = naiveUTC - off*60000;
            if (Math.abs(cand - guess) < 1) break;
            guess = cand;
          }
          offsets.add(this.getOffsetMinutes(timeZone, guess));
        }

        const candidates = [];
        for (const off of offsets) {
          const cand = naiveUTC - off*60000;
          if (this._matchesLocal(cand, timeZone, y, m, d, hh, mm)) candidates.push({ utcMs: cand, offsetMin: off });
        }
        candidates.sort((a,b) => a.utcMs - b.utcMs);
        const uniq = [];
        const seen = new Set();
        for (const c of candidates) {
          const k = String(c.utcMs);
          if (!seen.has(k)) { seen.add(k); uniq.push(c); }
        }
        return uniq;
      }

      static analyzeLocal(timeZone, y, m, d, hh, mm) {
        const cands = this.localToUtcCandidates(timeZone, y, m, d, hh, mm);
        if (cands.length === 0) return { kind: "nonexistent", candidates: [] };
        if (cands.length >= 2) return { kind: "ambiguous", candidates: cands.slice(0,2) };
        return { kind: "unique", candidates: cands };
      }

      static pickCandidate(analyzeResult, preference) {
        if (analyzeResult.kind === "unique") return analyzeResult.candidates[0];
        if (analyzeResult.kind === "nonexistent") return null;
        const [a,b] = analyzeResult.candidates;
        return (preference === "earlier") ? a : b;
      }

      static utcMsToISOZ(utcMs) { return new Date(utcMs).toISOString(); }
    }

    class SwissEphEngine {
      constructor() { this.swe = null; this.ready = null; }
      initOnce() {
        if (this.ready) return this.ready;
        this.ready = (async () => {
          this.swe = new SwissEph();
          await this.swe.initSwissEph();
          return this.swe;
        })();
        return this.ready;
      }
      getConst(name, fallback) {
        const v = this.swe?.[name];
        return (typeof v === "number") ? v : fallback;
      }
      calcJulianDayUTC(y, m, d, utHours) {
        return this.swe.julday(y, m, d, utHours);
      }
      calcBodies(jdUT) {
        const swe = this.swe;
        const flags = (this.getConst("SEFLG_SWIEPH", 2) | this.getConst("SEFLG_SPEED", 256));
        const list = [];
        for (const b of BODIES) {
          const id = swe[b.idKey];
          const res = swe.calc_ut(jdUT, id, flags);
          const lon = Number(res?.[0]);
          const lat = Number(res?.[1]);
          const lonSpeed = Number(res?.[3]);
          list.push({ ...b, id, lon: norm360(lon), lat, lonSpeed, retro: (lonSpeed < 0) });
        }
        return list;
      }
      parseHousesResult(raw) {
        let cusps = null, ascmc = null;
        if (Array.isArray(raw)) {
          if (raw.length >= 2 && (Array.isArray(raw[0]) || raw[0] instanceof Float64Array) && (Array.isArray(raw[1]) || raw[1] instanceof Float64Array)) {
            cusps = raw[0]; ascmc = raw[1];
          } else {
            cusps = raw;
          }
        } else if (raw && typeof raw === "object") {
          cusps = raw.cusps || raw.houses || raw.houseCusps || raw[0] || null;
          ascmc = raw.ascmc || raw.points || raw[1] || null;
        }

        const cuspArr = [];
        if (cusps) {
          for (let i = 1; i <= 12; i++) {
            const v = (cusps[i] !== undefined) ? cusps[i] : cusps[i-1];
            cuspArr.push(norm360(Number(v)));
          }
        } else {
          for (let i=0;i<12;i++) cuspArr.push(i*30);
        }

        const asc = ascmc ? norm360(Number(ascmc[0] ?? ascmc.asc ?? ascmc.ASC ?? ascmc.Asc ?? cuspArr[0])) : cuspArr[0];
        const mc  = ascmc ? norm360(Number(ascmc[1] ?? ascmc.mc  ?? ascmc.MC  ?? ascmc.Mc  ?? cuspArr[9])) : cuspArr[9];
        return { cusps: cuspArr, asc, mc };
      }
      calcHouses(jdUT, lat, lon) {
        const raw = this.swe.houses(jdUT, lat, lon, "P");
        return this.parseHousesResult(raw);
      }
      calcPlanetHouses(jdUT, lat, lon, planetPositions, houseSystem="P") {
        const swe = this.swe;
        const armcDeg = swe.sidtime(jdUT) * 15.0;
        const eps = 23.4392911;
        const out = new Map();
        for (const p of planetPositions) {
          const housePos = swe.house_pos(armcDeg, lat, eps, houseSystem, p.lon, p.lat ?? 0);
          const houseNum = Math.max(1, Math.min(12, Math.floor(Number(housePos) || 0)));
          out.set(p.key, houseNum);
        }
        return out;
      }
    }

    class AspectCalculator {
      static _orbLimit(aKey, bKey) {
        const lum = (k) => (k === "Sun" || k === "Moon");
        return (lum(aKey) || lum(bKey)) ? 8 : 6;
      }
      static findAspects(items) {
        const aspects = [];
        for (let i=0; i<items.length; i++) {
          for (let j=i+1; j<items.length; j++) {
            const A = items[i], B = items[j];
            const d = Math.abs(norm180(B.lon - A.lon));
            for (const asp of ASPECTS) {
              const orb = Math.abs(d - asp.angle);
              if (orb <= this._orbLimit(A.key, B.key)) aspects.push({ A, B, aspect: asp, orb });
            }
          }
        }
        return aspects.sort((x,y) => x.orb - y.orb);
      }
      static applyingOrSeparating(pair) {
        const { A, B, aspect } = pair;
        const dtDays = 1/24;
        const A2 = norm360(A.lon + (A.lonSpeed || 0) * dtDays);
        const B2 = norm360(B.lon + (B.lonSpeed || 0) * dtDays);
        const d1 = Math.abs(norm180(B.lon - A.lon));
        const d2 = Math.abs(norm180(B2 - A2));
        const orb1 = Math.abs(d1 - aspect.angle);
        const orb2 = Math.abs(d2 - aspect.angle);
        return (orb2 < orb1) ? "Applying" : "Separating";
      }
      static buildMatrix(items, aspectHits) {
        const n = items.length;
        const cell = Array.from({length:n}, () => Array.from({length:n}, () => null));
        for (const hit of aspectHits) {
          const i = items.findIndex(x => x.key === hit.A.key);
          const j = items.findIndex(x => x.key === hit.B.key);
          if (i >= 0 && j >= 0) { cell[i][j] = hit; cell[j][i] = hit; }
        }
        return cell;
      }
    }

    class ChartRenderer {
      constructor(container) { this.container = container; }
      render({ houses, bodies, aspects }) {
        const size = 520;
        const cx = size/2, cy = size/2;

        const R0 = 245, Rz = 215, Rh = 195, Rp = 155, Ra = 120, Rtext = 232;

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
        svg.setAttribute("width", String(size));
        svg.setAttribute("height", String(size));

        const add = (el) => (svg.appendChild(el), el);
        const circle = (r, stroke="#bbb", fill="none", w=1) => {
          const c = document.createElementNS(svg.namespaceURI, "circle");
          c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", r);
          c.setAttribute("stroke", stroke); c.setAttribute("fill", fill); c.setAttribute("stroke-width", w);
          return c;
        };
        const line = (x1,y1,x2,y2, stroke="#bbb", w=1, dash=null) => {
          const l = document.createElementNS(svg.namespaceURI, "line");
          l.setAttribute("x1", x1); l.setAttribute("y1", y1);
          l.setAttribute("x2", x2); l.setAttribute("y2", y2);
          l.setAttribute("stroke", stroke); l.setAttribute("stroke-width", w);
          if (dash) l.setAttribute("stroke-dasharray", dash);
          return l;
        };
        const text = (x,y, str, sizePx=12, anchor="middle", weight="600") => {
          const t = document.createElementNS(svg.namespaceURI, "text");
          t.setAttribute("x", x); t.setAttribute("y", y);
          t.setAttribute("font-size", sizePx);
          t.setAttribute("text-anchor", anchor);
          t.setAttribute("dominant-baseline", "middle");
          t.setAttribute("font-weight", weight);
          t.textContent = str;
          return t;
        };

        const polar = (r, angRad) => ({
          x: cx + r * Math.cos(angRad),
          y: cy - r * Math.sin(angRad)
        });

        const lonToAng = (lon) => deg2rad(90 + norm360(lon));

        add(circle(R0, "#999", "none", 1.2));
        add(circle(Rz, "#bbb", "none", 1));
        add(circle(Rh, "#bbb", "none", 1));
        add(circle(Rp, "#ddd", "none", 1));
        add(circle(Ra, "#eee", "none", 1));

        for (let i=0;i<12;i++) {
          const lonStart = i * 30;
          const lonEnd = (i + 1) * 30;
          const aStart = lonToAng(lonStart);
          const aEnd = lonToAng(lonEnd);

          const p1 = polar(R0, aStart);
          const p2 = polar(R0, aEnd);
          const p3 = polar(Rz, aEnd);
          const p4 = polar(Rz, aStart);

          const path = document.createElementNS(svg.namespaceURI, "path");
          const sweepOuter = 0;
          const sweepInner = 1;
          path.setAttribute("d",
            `M ${p4.x} ${p4.y}
             L ${p1.x} ${p1.y}
             A ${R0} ${R0} 0 0 ${sweepOuter} ${p2.x} ${p2.y}
             L ${p3.x} ${p3.y}
             A ${Rz} ${Rz} 0 0 ${sweepInner} ${p4.x} ${p4.y}
             Z`
          );
          path.setAttribute("fill", i%2===0 ? "#fcfcfc" : "#f5f5f5");
          path.setAttribute("stroke", "#e2e2e2");
          path.setAttribute("stroke-width", "1");
          add(path);

          const midLon = lonStart + 15;
          const pt = polar(Rtext, lonToAng(midLon));
          add(text(pt.x, pt.y, SIGNS[i].sym, 16, "middle", "800"));
        }

        const cuspLons = houses.cusps;
        for (let i=0;i<12;i++) {
          const ang = lonToAng(cuspLons[i]);
          const pIn = polar(Rh, ang);
          const pOut = polar(R0, ang);
          add(line(pIn.x, pIn.y, pOut.x, pOut.y, "#bdbdbd", 1));
          const labelPt = polar(Rh - 16, ang);
          add(text(labelPt.x, labelPt.y, String(i+1), 10, "middle", "900")).setAttribute("fill", "#666");
        }

        const ascAng = lonToAng(houses.asc);
        const dscAng = lonToAng(norm360(houses.asc + 180));
        const mcAng  = lonToAng(houses.mc);
        const icAng  = lonToAng(norm360(houses.mc + 180));

        const mark = (ang, label) => {
          const p1 = polar(Rh-6, ang);
          const p2 = polar(R0+2, ang);
          add(line(p1.x,p1.y,p2.x,p2.y,"#888",1.6));
          const pt = polar(R0+14, ang);
          add(text(pt.x, pt.y, label, 11, "middle", "900")).setAttribute("fill","#333");
        };
        mark(ascAng, "ASC");
        mark(dscAng, "DSC");
        mark(mcAng, "MC");
        mark(icAng, "IC");

        const aspectStyle = (name) => {
          if (name === "Kavuşum") return { w:1.2, dash:null, stroke:"#999" };
          if (name === "Karşıt")  return { w:1.2, dash:null, stroke:"#aaa" };
          if (name === "Kare")    return { w:1.1, dash:"4 3", stroke:"#aaa" };
          if (name === "Üçgen")   return { w:1.1, dash:"2 3", stroke:"#aaa" };
          if (name === "Sekstil") return { w:1.1, dash:"1 3", stroke:"#aaa" };
          return { w:1.1, dash:"2 2", stroke:"#aaa" };
        };

        const placements = bodies.map(b => ({ b, ang: lonToAng(b.lon) })).sort((x,y) => x.ang - y.ang);

        const minSep = deg2rad(7);
        for (let i=0;i<placements.length;i++) {
          let offset = 0;
          for (let j=i-1; j>=0; j--) {
            let da = Math.abs(placements[i].ang - placements[j].ang);
            while (da > Math.PI) da = Math.abs(da - 2*Math.PI);
            if (da < minSep) offset++;
            else break;
          }
          placements[i].r = Rp - offset*14;
        }

        const aspectLines = aspects.filter(x => x.orb <= 3.0);
        for (const hit of aspectLines) {
          const pa = placements.find(p => p.b.key === hit.A.key);
          const pb = placements.find(p => p.b.key === hit.B.key);
          if (!pa || !pb) continue;
          const A = polar(Ra, pa.ang);
          const B = polar(Ra, pb.ang);
          const st = aspectStyle(hit.aspect.name);
          add(line(A.x,A.y,B.x,B.y, st.stroke, st.w, st.dash));
        }

        for (const p of placements) {
          const pt = polar(p.r, p.ang);
          add(text(pt.x, pt.y, p.b.glyph, 18, "middle", "900")).setAttribute("fill", "#111");
          const namePt = polar(p.r + 18, p.ang);
          add(text(namePt.x, namePt.y, p.b.key, 9, "middle", "700")).setAttribute("fill", "#666");
          if (p.b.retro) {
            const rPt = polar(p.r - 18, p.ang);
            add(text(rPt.x, rPt.y, "R", 10, "middle", "900")).setAttribute("fill", "#666");
          }
        }

        this.container.innerHTML = "";
        this.container.appendChild(svg);
      }
    }

    class App {
      constructor() {
        this.nominatim = new NominatimService();
        this.tzSvc = new TimezoneService();
        this.engine = new SwissEphEngine();
        this.renderer = new ChartRenderer($("#chartWrap"));
        this.state = { loc: null, tz: null, disambiguation: "later" };

        this.dom = {
          statusBox: $("#statusBox"),
          dateInput: $("#dateInput"),
          timeInput: $("#timeInput"),
          datePretty: $("#datePretty"),
          locInput: $("#locInput"),
          locResults: $("#locResults"),
          latInput: $("#latInput"),
          lonInput: $("#lonInput"),
          tzSelect: $("#tzSelect"),
          dstBox: $("#dstBox"),
          calcBtn: $("#calcBtn"),
          locName: $("#locName"),
          locLatLon: $("#locLatLon"),
          locTz: $("#locTz"),
          locUtc: $("#locUtc"),
          planetTable: $("#planetTable tbody"),
          houseTable: $("#houseTable tbody"),
          aspectList: $("#aspectList tbody"),
          aspectMatrix: $("#aspectMatrix"),
          engineInfo: $("#engineInfo")
        };
      }

      async init() {
        this._initTimeZoneDropdown();
        this._initDefaults();
        this._bindUI();

        this._setStatus("WASM yükleniyor…", "tiny");
        try {
          await this.engine.initOnce();
          this._setStatus("Hazır. Lokasyon seç → hesapla.", "ok");
          this.dom.engineInfo.textContent = "Swiss Ephemeris: WASM (swisseph-wasm) • Placidus ev • Tropical zodyak";
        } catch (e) {
          console.error(e);
          this._setStatus("WASM import/init hatası. Console'a bak.", "error");
        }

        this._scheduleRecalc();
      }

      _setStatus(msg, kind="tiny") {
        const el = this.dom.statusBox;
        el.className = "";
        if (kind === "error") el.classList.add("error");
        else if (kind === "warn") el.classList.add("warn");
        else if (kind === "ok") el.classList.add("ok");
        else el.classList.add("tiny");
        el.textContent = msg || "";
      }

      _initTimeZoneDropdown() {
        const tzSel = this.dom.tzSelect;
        tzSel.innerHTML = "";
        for (const tz of this.tzSvc.tzList) {
          const opt = document.createElement("option");
          opt.value = tz;
          opt.textContent = tz;
          tzSel.appendChild(opt);
        }
      }

      _initDefaults() {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = pad2(now.getMonth()+1);
        const dd = pad2(now.getDate());
        const hh = pad2(now.getHours());
        const mi = pad2(now.getMinutes());

        this.dom.dateInput.value = `${yyyy}-${mm}-${dd}`;
        this.dom.timeInput.value = `${hh}:${mi}`;
        this._updateDatePretty();

        const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
        const fallbackTz = isSupportedIana(browserTz) ? browserTz : "UTC";
        if ([...this.dom.tzSelect.options].some(o => o.value === fallbackTz)) this.dom.tzSelect.value = fallbackTz;
        else this.dom.tzSelect.value = "UTC";

        this.state.tz = this.dom.tzSelect.value;
        this._renderLocSummary();
      }

      _bindUI() {
        const debouncedLocSearch = debounce(async () => {
          const q = this.dom.locInput.value.trim();
          if (q.length < 3) { this._hideLocResults(); return; }
          try {
            const items = await this.nominatim.search(q);
            this._showLocResults(items);
          } catch (e) {
            console.error(e);
            this._setStatus("Lokasyon araması hata verdi (Nominatim).", "warn");
            this._hideLocResults();
          }
        }, 350);

        this.dom.locInput.addEventListener("input", () => debouncedLocSearch());

        document.addEventListener("click", (ev) => {
          if (!this.dom.locInput.contains(ev.target) && !this.dom.locResults.contains(ev.target)) this._hideLocResults();
        });

        const autoRecalc = debounce(() => this._recalc(), 450);

        this.dom.dateInput.addEventListener("change", () => { this._updateDatePretty(); this._scheduleRecalc(autoRecalc); });
        this.dom.timeInput.addEventListener("change", () => { this._scheduleRecalc(autoRecalc); });
        this.dom.tzSelect.addEventListener("change", () => {
          this.state.tz = this.dom.tzSelect.value;
          this._updateDSTBox();
          this._scheduleRecalc(autoRecalc);
        });

        this.dom.calcBtn.addEventListener("click", () => this._recalc());
      }

      _updateDatePretty() {
        const v = this.dom.dateInput.value;
        const m = v.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        this.dom.datePretty.textContent = m ? `gün/ay/yıl: ${m[3]}/${m[2]}/${m[1]}` : "";
      }

      _scheduleRecalc(fn) { (fn || debounce(() => this._recalc(), 450))(); }

      _showLocResults(items) {
        const box = this.dom.locResults;
        box.innerHTML = "";
        if (!items.length) {
          const div = document.createElement("div");
          div.style.padding = "10px 12px";
          div.className = "tiny";
          div.textContent = "Sonuç yok.";
          box.appendChild(div);
        } else {
          for (const it of items) {
            const b = document.createElement("button");
            b.type = "button";
            b.textContent = it.displayName;
            b.addEventListener("click", () => { this._selectLocation(it); this._hideLocResults(); });
            box.appendChild(b);
          }
        }
        box.style.display = "block";
      }

      _hideLocResults() { this.dom.locResults.style.display = "none"; }

      _selectLocation(it) {
        this.state.loc = { ...it };
        this.dom.locInput.value = it.displayName;
        this.dom.latInput.value = String(it.lat);
        this.dom.lonInput.value = String(it.lon);

        let tz = null;
        try { tz = this.tzSvc.lookup(it.lat, it.lon); } catch (e) { console.error(e); }

        if (tz) {
          this.state.tz = tz;
          if ([...this.dom.tzSelect.options].some(o => o.value === tz)) {
            this.dom.tzSelect.value = tz;
          } else {
            const opt = document.createElement("option");
            opt.value = tz;
            opt.textContent = tz;
            this.dom.tzSelect.appendChild(opt);
            this.dom.tzSelect.value = tz;
          }
        } else {
          this._setStatus("Timezone otomatik bulunamadı. Dropdown’dan elle seç.", "warn");
        }

        this._updateDSTBox();
        this._renderLocSummary();
        this._scheduleRecalc();
      }

      _parseInputs() {
        const d = this.dom.dateInput.value.trim();
        const t = this.dom.timeInput.value.trim();
        const tz = this.state.tz || this.dom.tzSelect.value;

        const md = d.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        const mt = t.match(/^(\d{2}):(\d{2})$/);
        if (!md) throw new Error("Tarih seç (date picker).");
        if (!mt) throw new Error("Saat seç (time picker).");
        if (!tz) throw new Error("Timezone yok.");
        if (!isSupportedIana(tz)) throw new Error(`Timezone desteklenmiyor: ${tz}`);

        return { year: Number(md[1]), month: Number(md[2]), day: Number(md[3]), hour: Number(mt[1]), minute: Number(mt[2]), tz };
      }

      _updateDSTBox() {
        const box = this.dom.dstBox;
        box.style.display = "none";
        box.innerHTML = "";

        let parsed;
        try { parsed = this._parseInputs(); } catch { return; }

        const { year, month, day, hour, minute, tz } = parsed;

        let info;
        try { info = TimeZoneMath.analyzeLocal(tz, year, month, day, hour, minute); }
        catch (e) {
          console.error(e);
          box.style.display = "block";
          const w = document.createElement("div");
          w.className = "warn";
          w.textContent = `DST kontrolü yapılamadı: ${e.message || e}`;
          box.appendChild(w);
          return;
        }

        if (info.kind === "unique") { this.state.disambiguation = "later"; return; }

        box.style.display = "block";
        const wrap = document.createElement("div");
        wrap.className = "warn";

        if (info.kind === "nonexistent") {
          wrap.innerHTML = `
            <div style="font-weight:900;margin-bottom:6px;">DST: Bu yerel saat yok (ileri atlama / gap).</div>
            <div class="small">Bu zamanı hesaplayamazsın çünkü o dakika o bölgede yaşanmamış. Başka saat seç.</div>
          `;
        }

        if (info.kind === "ambiguous") {
          const [earlier, later] = info.candidates;
          wrap.innerHTML = `
            <div style="font-weight:900;margin-bottom:6px;">DST: Bu yerel saat iki kez yaşanıyor (ambiguous / fold).</div>
            <div class="small">Varsayılan: <b>later offset</b>. İstersen diğerini seç.</div>
            <div style="margin-top:10px; display:grid; gap:8px;">
              <label class="small"><input type="radio" name="dstPick" value="earlier"> Earlier (UTC: <span class="mono">${TimeZoneMath.utcMsToISOZ(earlier.utcMs)}</span>)</label>
              <label class="small"><input type="radio" name="dstPick" value="later" checked> Later (UTC: <span class="mono">${TimeZoneMath.utcMsToISOZ(later.utcMs)}</span>)</label>
            </div>
          `;
          setTimeout(() => {
            const radios = box.querySelectorAll('input[name="dstPick"]');
            radios.forEach(r => r.addEventListener("change", () => {
              this.state.disambiguation = r.value;
              this._renderLocSummary();
              this._scheduleRecalc();
            }));
          }, 0);
          this.state.disambiguation = "later";
        }

        box.appendChild(wrap);
      }

      _renderLocSummary() {
        const loc = this.state.loc;
        const tz = this.state.tz || this.dom.tzSelect.value;

        this.dom.locName.textContent = loc?.displayName || "—";
        this.dom.locLatLon.textContent = (loc ? `${loc.lat.toFixed(6)}, ${loc.lon.toFixed(6)}` : "—");
        this.dom.locTz.textContent = tz || "—";

        try {
          const { year, month, day, hour, minute } = this._parseInputs();
          const info = TimeZoneMath.analyzeLocal(tz, year, month, day, hour, minute);
          const picked = TimeZoneMath.pickCandidate(info, this.state.disambiguation || "later");
          this.dom.locUtc.textContent = picked ? TimeZoneMath.utcMsToISOZ(picked.utcMs) : "—";
        } catch {
          this.dom.locUtc.textContent = "—";
        }
      }

      async _recalc() {
        if (!this.engine.ready) { this._setStatus("WASM henüz hazır değil.", "warn"); return; }

        let parsed;
        try { parsed = this._parseInputs(); }
        catch (e) { this._setStatus(e.message, "warn"); return; }

        const loc = this.state.loc;
        if (!loc) { this._setStatus("Lokasyon seçilmedi. Arama kutusundan bir yer seç.", "warn"); return; }

        const { year, month, day, hour, minute, tz } = parsed;

        this._updateDSTBox();

        let picked;
        try {
          const info = TimeZoneMath.analyzeLocal(tz, year, month, day, hour, minute);
          picked = TimeZoneMath.pickCandidate(info, this.state.disambiguation || "later");
          if (!picked) {
            this._setStatus("Bu yerel saat o timezone’da yok (DST gap). Başka saat seç.", "error");
            this._renderLocSummary();
            return;
          }
        } catch (e) {
          console.error(e);
          this._setStatus(`Timezone dönüşümü hata verdi: ${e.message || e}`, "error");
          return;
        }

        this._renderLocSummary();

        const utc = new Date(picked.utcMs);
        const y = utc.getUTCFullYear();
        const m = utc.getUTCMonth() + 1;
        const d = utc.getUTCDate();
        const utHours = utc.getUTCHours() + utc.getUTCMinutes()/60 + utc.getUTCSeconds()/3600;

        this._setStatus("Hesaplanıyor…", "tiny");
        try {
          await this.engine.initOnce();

          const jdUT = this.engine.calcJulianDayUTC(y, m, d, utHours);
          const houses = this.engine.calcHouses(jdUT, loc.lat, loc.lon);
          const bodies = this.engine.calcBodies(jdUT);

          const houseMap = this.engine.calcPlanetHouses(jdUT, loc.lat, loc.lon, bodies, "P");
          for (const b of bodies) b.house = houseMap.get(b.key) || 0;

          const aspects = AspectCalculator.findAspects(bodies);

          this._renderPlanetTable(bodies);
          this._renderHouseTable(houses);
          this._renderAspectList(aspects);
          this._renderAspectMatrix(bodies, aspects);
          this.renderer.render({ houses, bodies, aspects });

          this._setStatus("Tamam.", "ok");
        } catch (e) {
          console.error(e);
          this._setStatus(`Hesaplama hatası: ${e.message || e}`, "error");
        }
      }

      _renderPlanetTable(bodies) {
        const tb = this.dom.planetTable;
        tb.innerHTML = "";
        for (const b of bodies) {
          const dms = fmtDMS(b.lon);
          const sign = SIGNS[dms.signIndex];
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td><span class="mono">${b.glyph}</span> ${b.label}</td>
            <td class="mono">${b.lon.toFixed(6)}</td>
            <td>${sign.sym} ${sign.name}</td>
            <td class="mono">${pad2(dms.dd)}°${pad2(dms.mm)}′${pad2(dms.ss)}″</td>
            <td class="center mono">${b.retro ? "R" : ""}</td>
            <td class="center mono">${b.house || ""}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderHouseTable(houses) {
        const tb = this.dom.houseTable;
        tb.innerHTML = "";
        for (let i=0; i<12; i++) {
          const lon = houses.cusps[i];
          const dms = fmtDMS(lon);
          const sign = SIGNS[dms.signIndex];
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td class="center mono">${i+1}</td>
            <td>${sign.sym} ${sign.name}</td>
            <td class="mono">${pad2(dms.dd)}°${pad2(dms.mm)}′${pad2(dms.ss)}″</td>
            <td class="mono">${lon.toFixed(6)}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderAspectList(aspects) {
        const tb = this.dom.aspectList;
        tb.innerHTML = "";
        for (const a of aspects) {
          const appsep = AspectCalculator.applyingOrSeparating(a);
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${a.A.label}</td>
            <td>${a.B.label}</td>
            <td class="mono">${a.aspect.sym} ${a.aspect.name} (${a.aspect.angle}°)</td>
            <td class="mono">${orbToText(a.orb)}</td>
            <td class="mono">${appsep}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderAspectMatrix(bodies, aspects) {
        const tbl = this.dom.aspectMatrix;
        tbl.innerHTML = "";

        const hits = AspectCalculator.buildMatrix(bodies, aspects);

        const thead = document.createElement("thead");
        const hrow = document.createElement("tr");
        hrow.appendChild(Object.assign(document.createElement("th"), { textContent: "" }));
        for (const b of bodies) {
          const th = document.createElement("th");
          th.className = "aspectCell";
          th.innerHTML = `<span class="mono">${b.glyph}</span><div class="small muted">${b.key}</div>`;
          hrow.appendChild(th);
        }
        thead.appendChild(hrow);
        tbl.appendChild(thead);

        const tbody = document.createElement("tbody");
        for (let i=0;i<bodies.length;i++) {
          const tr = document.createElement("tr");
          const rowH = document.createElement("th");
          rowH.className = "aspectCell";
          rowH.innerHTML = `<span class="mono">${bodies[i].glyph}</span><div class="small muted">${bodies[i].key}</div>`;
          tr.appendChild(rowH);

          for (let j=0;j<bodies.length;j++) {
            const td = document.createElement("td");
            td.className = "aspectCell";
            if (i === j) { td.textContent = "—"; td.classList.add("muted"); }
            else {
              const hit = hits[i][j];
              if (hit) td.innerHTML = `<span class="mono">${hit.aspect.sym}</span> <span class="mono">${orbToText(hit.orb)}</span>`;
              else td.textContent = "";
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        tbl.appendChild(tbody);
      }
    }

    const app = new App();
    await app.init();
  </script>
</body>
</html>

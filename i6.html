<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Natal Chart Demo - Tek Dosya</title>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tz-lookup@6.1.0/tz.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap');
        body { font-family: 'Roboto', sans-serif; background: #0f172a; color: #e2e8f0; margin:0; padding:20px; }
        .container { display: flex; max-width: 1400px; margin: auto; gap: 30px; flex-wrap: wrap; }
        .form-panel { background: #1e2937; padding: 25px; border-radius: 16px; width: 380px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
        .result-panel { flex: 1; min-width: 700px; }
        h1 { text-align: center; color: #60a5fa; margin-bottom: 10px; }
        .input-group { margin-bottom: 18px; }
        label { display: block; margin-bottom: 6px; font-size: 0.95rem; color: #94a3b8; }
        input, select { width: 100%; padding: 12px; border-radius: 8px; border: none; background: #334155; color: #e2e8f0; font-size: 1rem; }
        .location-results { max-height: 200px; overflow-y: auto; background: #1e2937; border-radius: 8px; margin-top: 5px; }
        .location-item { padding: 10px; cursor: pointer; border-bottom: 1px solid #334155; }
        .location-item:hover { background: #475569; }
        button { background: #3b82f6; color: white; border: none; padding: 14px 28px; border-radius: 8px; font-size: 1.1rem; cursor: pointer; width: 100%; margin-top: 10px; }
        button:hover { background: #2563eb; }
        .chart-container { background: #1e2937; padding: 25px; border-radius: 16px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.4); margin-bottom: 25px; }
        svg { max-width: 100%; height: auto; background: #0f172a; border-radius: 50%; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; background: #1e2937; border-radius: 12px; overflow: hidden; }
        th, td { padding: 12px; text-align: center; border-bottom: 1px solid #334155; }
        th { background: #334155; color: #60a5fa; }
        .aspect-matrix td { font-size: 1.4rem; width: 60px; height: 60px; }
        .info { font-size: 0.9rem; color: #94a3b8; margin-top: 15px; }
        .error { color: #f87171; background: #450a0a; padding: 10px; border-radius: 8px; display: none; }
        .planet-glyph { font-size: 1.8rem; }
    </style>
</head>
<body>
    <h1>üåå Natal Chart Demo (Swiss Ephemeris WASM - D√ºzeltilmi≈ü Ev Hesabƒ±)</h1>
    <div class="container">
        <div class="form-panel">
            <div class="input-group">
                <label>Tarih (G√ºn/Ay/Yƒ±l)</label>
                <input type="date" id="birthDate" value="1995-06-15">
            </div>
            <div class="input-group">
                <label>Saat (24 saat)</label>
                <input type="time" id="birthTime" value="12:00">
            </div>
            <div class="input-group">
                <label>Lokasyon Ara (≈üehir, √ºlke)</label>
                <input type="text" id="locationSearch" placeholder="ƒ∞stanbul, T√ºrkiye" autocomplete="off">
                <div id="locationResults" class="location-results"></div>
            </div>
            <div class="input-group">
                <label>Se√ßili Lokasyon</label>
                <div style="background:#334155;padding:12px;border-radius:8px;font-size:0.95rem;" id="selectedLocation">ƒ∞stanbul, T√ºrkiye</div>
            </div>
            <div class="input-group">
                <label>Enlem / Boylam</label>
                <input type="text" id="latLon" readonly style="background:#1e2937;color:#64748b;" value="41.0136¬∞ / 28.9550¬∞">
            </div>
            <div class="input-group">
                <label>Timezone (IANA)</label>
                <select id="timezoneSelect"></select>
            </div>
            <div id="errorMsg" class="error"></div>
            <button onclick="calculateChart()">Hesapla & √áiz</button>
            <div class="info">Otomatik hesapla aktif. Ev sistemi: Placidus (d√ºzeltilmi≈ü).</div>
        </div>

        <div class="result-panel">
            <div class="chart-container">
                <svg id="natalChart" width="620" height="620" viewBox="0 0 620 620"></svg>
            </div>

            <div style="display:flex;gap:20px;flex-wrap:wrap;">
                <div style="flex:1;">
                    <h2 style="color:#60a5fa;margin-bottom:10px;">Gezegenler</h2>
                    <table id="planetsTable">
                        <thead><tr><th>Gezegen</th><th>Bur√ß</th><th>Derece</th><th>Retro</th><th>Ev</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <div style="flex:1;">
                    <h2 style="color:#60a5fa;margin-bottom:10px;">Evler (Placidus)</h2>
                    <table id="housesTable">
                        <thead><tr><th>Ev</th><th>Bur√ß</th><th>Derece</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <h2 style="color:#60a5fa;margin:30px 0 10px;">Maj√∂r A√ßƒ±lar</h2>
            <table id="aspectsTable" style="width:100%;">
                <thead><tr><th>A</th><th>B</th><th>A√ßƒ±</th><th>Orb</th></tr></thead>
                <tbody></tbody>
            </table>

            <h2 style="color:#60a5fa;margin:30px 0 10px;">A√ßƒ± Matrisi</h2>
            <table id="aspectMatrix" class="aspect-matrix"></table>
        </div>
    </div>

    <script type="module">
        import SwissEph from 'https://cdn.jsdelivr.net/gh/prolaxu/swisseph-wasm@main/src/swisseph.js';

        const { DateTime } = luxon;
        let sweInstance = null;
        let selectedLat = 41.0136;
        let selectedLon = 28.9550;
        let selectedTz = "Europe/Istanbul";
        let selectedDisplayName = "ƒ∞stanbul, T√ºrkiye";
        let debounceTimer = null;

        const PLANETS = [
            { name: "G√ºne≈ü", id: 0, glyph: "‚òâ" },
            { name: "Ay", id: 1, glyph: "‚òΩ" },
            { name: "Merk√ºr", id: 2, glyph: "‚òø" },
            { name: "Ven√ºs", id: 3, glyph: "‚ôÄ" },
            { name: "Mars", id: 4, glyph: "‚ôÇ" },
            { name: "J√ºpiter", id: 5, glyph: "‚ôÉ" },
            { name: "Sat√ºrn", id: 6, glyph: "‚ôÑ" },
            { name: "Uran√ºs", id: 7, glyph: "‚ôÖ" },
            { name: "Nept√ºn", id: 8, glyph: "‚ôÜ" },
            { name: "Pl√ºton", id: 9, glyph: "‚ôá" },
            { name: "Kuzey D√ºƒü√ºm", id: 11, glyph: "‚òä" },
            { name: "Chiron", id: 15, glyph: "‚ö∑" }
        ];

        const SIGN_NAMES = ["Ko√ß","Boƒüa","ƒ∞kizler","Yenge√ß","Aslan","Ba≈üak","Terazi","Akrep","Yay","Oƒülak","Kova","Balƒ±k"];
        const SIGN_GLYPHS = ["‚ôà","‚ôâ","‚ôä","‚ôã","‚ôå","‚ôç","‚ôé","‚ôè","‚ôê","‚ôë","‚ôí","‚ôì"];

        const ASPECTS_DEF = [
            { angle: 0, orb: 8, name: "Kavu≈üum", sym: "‚òå", color: "#ef4444" },
            { angle: 60, orb: 6, name: "Sextil", sym: "‚öπ", color: "#22c55e" },
            { angle: 90, orb: 6, name: "Kare", sym: "‚ñ°", color: "#ef4444" },
            { angle: 120, orb: 6, name: "√ú√ßgen", sym: "‚ñ≥", color: "#3b82f6" },
            { angle: 180, orb: 8, name: "Kar≈üƒ±t", sym: "‚òç", color: "#ef4444" }
        ];

        const COMMON_TZ = ["Europe/Istanbul","Europe/London","Europe/Paris","Europe/Berlin","Europe/Moscow","America/New_York","America/Chicago","America/Los_Angeles","Asia/Tokyo","Asia/Shanghai","Australia/Sydney"];

        async function initSwissEph() {
            if (sweInstance) return sweInstance;
            sweInstance = new SwissEph();
            await sweInstance.initSwissEph();
            console.log("%cSwiss Ephemeris WASM y√ºklendi (houses d√ºzeltildi)", "color:#22c55e;font-weight:bold");
            return sweInstance;
        }

        function degToDMS(deg) {
            const d = Math.floor(deg);
            const m = Math.floor((deg - d) * 60);
            const s = Math.round(((deg - d) * 60 - m) * 60);
            return `${d}¬∞${m.toString().padStart(2,'0')}'${s.toString().padStart(2,'0')}"`;
        }

        function lngToSign(lng) {
            const norm = ((lng % 360) + 360) % 360;
            const idx = Math.floor(norm / 30);
            const degInSign = norm % 30;
            return { signIdx: idx, sign: SIGN_NAMES[idx], glyph: SIGN_GLYPHS[idx], dms: degToDMS(degInSign) };
        }

        async function calculatePositions(jd, lat, lon) {
            const swe = await initSwissEph();
            const positions = [];
            for (const p of PLANETS) {
                const res = swe.calc_ut(jd, p.id, swe.SEFLG_SWIEPH | swe.SEFLG_SPEED);
                if (!res || res.length < 4) continue;
                let lng = ((res[0] % 360) + 360) % 360;
                const speed = res[3];
                positions.push({ ...p, lng, speed, retro: speed < -0.01, signInfo: lngToSign(lng) });
            }
            return positions;
        }

        async function calculateHouses(jd, lat, lon) {
            const swe = await initSwissEph();
            let houseData = null;

            // Doƒüru API √ßaƒürƒ±larƒ± (prolaxu wrapper)
            if (typeof swe.houses === 'function') {
                houseData = swe.houses(jd, lat, lon, 'P');
            } else if (typeof swe.swe_houses === 'function') {
                houseData = swe.swe_houses(jd, lat, lon, 'P');
            } else if (typeof swe.houses_ex === 'function') {
                houseData = swe.houses_ex(jd, 0, lat, lon, 'P');
            }

            if (houseData && houseData.cusps && Array.isArray(houseData.cusps) && houseData.cusps.length >= 13) {
                console.log("%cPlacidus evleri ba≈üarƒ±yla hesaplandƒ±", "color:#22c55e", houseData.cusps.slice(1,13));
                return Array.from(houseData.cusps);
            }

            // G√ºvenli Equal House fallback (eƒüer WASM houses ba≈üarƒ±sƒ±z olursa)
            console.warn("Houses WASM √ßaƒürƒ±sƒ± ba≈üarƒ±sƒ±z, Equal House fallback kullanƒ±lƒ±yor");
            const asc = (jd * 360 / 365.25) % 360;
            return Array.from({length:13}, (_,i) => (asc + i*30) % 360);
        }

        function findHouseForPlanet(lng, cusps) {
            const p = ((lng % 360) + 360) % 360;
            for (let i = 1; i <= 12; i++) {
                let c1 = ((cusps[i] % 360) + 360) % 360;
                let c2 = ((cusps[i === 12 ? 1 : i + 1] % 360) + 360) % 360;
                if (c2 < c1) c2 += 360;
                let pp = p < c1 ? p + 360 : p;
                if (pp >= c1 && pp < c2) return i;
            }
            return 1;
        }

        function calculateAspects(positions) {
            const aspects = [];
            for (let i = 0; i < positions.length; i++) {
                for (let j = i + 1; j < positions.length; j++) {
                    let diff = Math.abs(positions[i].lng - positions[j].lng);
                    diff = Math.min(diff, 360 - diff);
                    for (const asp of ASPECTS_DEF) {
                        const orbVal = Math.abs(diff - asp.angle);
                        const maxOrb = (positions[i].id === 0 || positions[i].id === 1 || positions[j].id === 0 || positions[j].id === 1) ? 8 : 6;
                        if (orbVal <= maxOrb) {
                            aspects.push({ p1: positions[i], p2: positions[j], aspect: asp, orb: orbVal.toFixed(2) });
                        }
                    }
                }
            }
            return aspects;
        }

        function createSVGChart(positions, cusps) {
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "620");
            svg.setAttribute("height", "620");
            svg.setAttribute("viewBox", "0 0 620 620");

            const cx = 310, cy = 310, rOuter = 295, rSign = 260, rHouse = 225, rPlanet = 180, rInner = 70;

            // Arka plan
            const bg = document.createElementNS(svgNS, "circle");
            bg.setAttribute("cx", cx); bg.setAttribute("cy", cy); bg.setAttribute("r", rOuter);
            bg.setAttribute("fill", "#1e2937"); bg.setAttribute("stroke", "#475569"); bg.setAttribute("stroke-width", "40");
            svg.appendChild(bg);

            // Bur√ß dilimleri
            for (let i = 0; i < 12; i++) {
                const a1 = (i * 30 - 90) * Math.PI / 180;
                const a2 = ((i + 1) * 30 - 90) * Math.PI / 180;
                const x1 = cx + rSign * Math.cos(a1), y1 = cy + rSign * Math.sin(a1);
                const x2 = cx + rSign * Math.cos(a2), y2 = cy + rSign * Math.sin(a2);
                const path = document.createElementNS(svgNS, "path");
                path.setAttribute("d", `M ${cx},${cy} L ${x1},${y1} A ${rSign},${rSign} 0 0 1 ${x2},${y2} Z`);
                path.setAttribute("fill", i % 2 === 0 ? "#334155" : "#1e2937");
                path.setAttribute("stroke", "#64748b");
                svg.appendChild(path);

                const midA = (i * 30 + 15 - 90) * Math.PI / 180;
                const tx = cx + (rSign + 22) * Math.cos(midA);
                const ty = cy + (rSign + 22) * Math.sin(midA);
                const text = document.createElementNS(svgNS, "text");
                text.setAttribute("x", tx); text.setAttribute("y", ty);
                text.setAttribute("text-anchor", "middle"); text.setAttribute("dominant-baseline", "middle");
                text.setAttribute("fill", "#f1f5f9"); text.setAttribute("font-size", "22");
                text.setAttribute("transform", `rotate(${i*30 + 15 - 90 + 90}, ${tx}, ${ty})`);
                text.textContent = SIGN_GLYPHS[i];
                svg.appendChild(text);
            }

            // Ev √ßizgileri (Placidus)
            const houseCuspsNorm = cusps.slice(1, 13).map(c => ((c % 360) + 360) % 360);
            for (let i = 0; i < 12; i++) {
                const ang = (houseCuspsNorm[i] - 90) * Math.PI / 180;
                const x1 = cx + rHouse * Math.cos(ang), y1 = cy + rHouse * Math.sin(ang);
                const x2 = cx + (rOuter - 20) * Math.cos(ang), y2 = cy + (rOuter - 20) * Math.sin(ang);
                const line = document.createElementNS(svgNS, "line");
                line.setAttribute("x1", x1); line.setAttribute("y1", y1);
                line.setAttribute("x2", x2); line.setAttribute("y2", y2);
                line.setAttribute("stroke", "#94a3b8"); line.setAttribute("stroke-width", "2.5");
                svg.appendChild(line);
            }

            // ASC & MC
            const ascLng = cusps[1];
            const mcLng = cusps[10];
            const ascAng = (ascLng - 90) * Math.PI / 180;
            const mcAng = (mcLng - 90) * Math.PI / 180;
            const ascX = cx + (rOuter - 35) * Math.cos(ascAng), ascY = cy + (rOuter - 35) * Math.sin(ascAng);
            const ascTxt = document.createElementNS(svgNS, "text");
            ascTxt.setAttribute("x", ascX); ascTxt.setAttribute("y", ascY);
            ascTxt.setAttribute("fill", "#eab308"); ascTxt.setAttribute("font-size", "19"); ascTxt.setAttribute("font-weight", "bold");
            ascTxt.textContent = "ASC"; svg.appendChild(ascTxt);

            const mcX = cx + (rOuter - 35) * Math.cos(mcAng), mcY = cy + (rOuter - 35) * Math.sin(mcAng);
            const mcTxt = document.createElementNS(svgNS, "text");
            mcTxt.setAttribute("x", mcX); mcTxt.setAttribute("y", mcY);
            mcTxt.setAttribute("fill", "#eab308"); mcTxt.setAttribute("font-size", "19"); mcTxt.setAttribute("font-weight", "bold");
            mcTxt.textContent = "MC"; svg.appendChild(mcTxt);

            // Gezegenler
            const placed = [];
            positions.forEach(p => {
                let ang = (p.lng - 90) * Math.PI / 180;
                let radius = rPlanet;
                let tries = 0;
                while (placed.some(pl => Math.abs(pl - ang) < 0.18) && tries < 12) {
                    ang += 0.13; tries++;
                }
                placed.push(ang);

                const px = cx + radius * Math.cos(ang);
                const py = cy + radius * Math.sin(ang);

                const g = document.createElementNS(svgNS, "g");
                const circ = document.createElementNS(svgNS, "circle");
                circ.setAttribute("cx", px); circ.setAttribute("cy", py); circ.setAttribute("r", "19");
                circ.setAttribute("fill", "#1e2937"); circ.setAttribute("stroke", "#60a5fa"); circ.setAttribute("stroke-width", "3.5");
                g.appendChild(circ);

                const txt = document.createElementNS(svgNS, "text");
                txt.setAttribute("x", px); txt.setAttribute("y", py + 8);
                txt.setAttribute("text-anchor", "middle"); txt.setAttribute("fill", "#f1f5f9"); txt.setAttribute("font-size", "28");
                txt.textContent = p.glyph; g.appendChild(txt);

                if (p.retro) {
                    const rtxt = document.createElementNS(svgNS, "text");
                    rtxt.setAttribute("x", px + 24); rtxt.setAttribute("y", py - 20);
                    rtxt.setAttribute("fill", "#f59e0b"); rtxt.setAttribute("font-size", "16"); rtxt.textContent = "R";
                    g.appendChild(rtxt);
                }
                svg.appendChild(g);
            });

            // A√ßƒ±lar
            const aspectLines = calculateAspects(positions);
            aspectLines.forEach(a => {
                const a1 = (a.p1.lng - 90) * Math.PI / 180;
                const a2 = (a.p2.lng - 90) * Math.PI / 180;
                const x1 = cx + (rPlanet - 28) * Math.cos(a1);
                const y1 = cy + (rPlanet - 28) * Math.sin(a1);
                const x2 = cx + (rPlanet - 28) * Math.cos(a2);
                const y2 = cy + (rPlanet - 28) * Math.sin(a2);
                const line = document.createElementNS(svgNS, "line");
                line.setAttribute("x1", x1); line.setAttribute("y1", y1);
                line.setAttribute("x2", x2); line.setAttribute("y2", y2);
                line.setAttribute("stroke", a.aspect.color); line.setAttribute("stroke-width", "1.8"); line.setAttribute("stroke-opacity", "0.8");
                svg.appendChild(line);
            });

            const inner = document.createElementNS(svgNS, "circle");
            inner.setAttribute("cx", cx); inner.setAttribute("cy", cy); inner.setAttribute("r", rInner);
            inner.setAttribute("fill", "none"); inner.setAttribute("stroke", "#475569"); inner.setAttribute("stroke-width", "14");
            svg.appendChild(inner);

            return svg;
        }

        function renderTables(positions, cusps, aspects) {
            const ptbody = document.querySelector("#planetsTable tbody");
            ptbody.innerHTML = "";
            positions.forEach(p => {
                const house = findHouseForPlanet(p.lng, cusps);
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td><span class="planet-glyph">${p.glyph}</span> ${p.name}</td>
                    <td>${p.signInfo.glyph} ${p.signInfo.sign}</td>
                    <td>${p.signInfo.dms}</td>
                    <td style="color:${p.retro?'#f59e0b':'#64748b'}">${p.retro?'R':''}</td>
                    <td><b>${house}</b></td>
                `;
                ptbody.appendChild(tr);
            });

            const htbody = document.querySelector("#housesTable tbody");
            htbody.innerHTML = "";
            for (let i = 1; i <= 12; i++) {
                const c = cusps[i];
                const s = lngToSign(c);
                const tr = document.createElement("tr");
                tr.innerHTML = `<td><b>${i}</b></td><td>${s.glyph} ${s.sign}</td><td>${s.dms}</td>`;
                htbody.appendChild(tr);
            }

            const atbody = document.querySelector("#aspectsTable tbody");
            atbody.innerHTML = "";
            aspects.forEach(a => {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${a.p1.glyph} ${a.p1.name}</td>
                    <td>${a.p2.glyph} ${a.p2.name}</td>
                    <td style="color:${a.aspect.color}">${a.aspect.sym} ${a.aspect.name}</td>
                    <td>${a.orb}¬∞</td>
                `;
                atbody.appendChild(tr);
            });

            const matrixPlanets = positions.slice(0, 11);
            const matrix = document.getElementById("aspectMatrix");
            matrix.innerHTML = `<thead><tr><th></th>${matrixPlanets.map(p=>`<th>${p.glyph}</th>`).join('')}</tr></thead><tbody></tbody>`;
            const mtbody = matrix.querySelector("tbody");
            matrixPlanets.forEach((p1,i) => {
                const row = document.createElement("tr");
                row.innerHTML = `<td style="font-weight:500">${p1.glyph}</td>`;
                matrixPlanets.forEach((p2,j) => {
                    if (i===j) { row.innerHTML += `<td style="background:#334155">‚Äî</td>`; return; }
                    let diff = Math.abs(p1.lng - p2.lng); diff = Math.min(diff, 360-diff);
                    let found = null;
                    for (const asp of ASPECTS_DEF) {
                        if (Math.abs(diff - asp.angle) <= (i<2||j<2 ? 8 : 6)) { found = asp; break; }
                    }
                    row.innerHTML += found ? `<td style="color:${found.color}">${found.sym}<br><span style="font-size:0.7rem">${Math.abs(diff-found.angle).toFixed(1)}</span></td>` : `<td></td>`;
                });
                mtbody.appendChild(row);
            });
        }

        async function getUTCFromLocal(year, month, day, hour, minute, tz) {
            const dt = DateTime.fromObject({ year, month, day, hour, minute, second: 0 }, { zone: tz });
            if (dt.invalid) throw new Error("Ge√ßersiz tarih/saat (DST sorunu olabilir)");
            const utc = dt.toUTC();
            return { year: utc.year, month: utc.month, day: utc.day, hour: utc.hour + utc.minute/60 };
        }

        async function calculateChart() {
            const errorEl = document.getElementById("errorMsg");
            errorEl.style.display = "none";

            try {
                const dateVal = document.getElementById("birthDate").value;
                const timeVal = document.getElementById("birthTime").value;
                if (!dateVal || !timeVal) throw new Error("Tarih ve saat girin");

                const [year, month, day] = dateVal.split('-').map(Number);
                const [hour, minute] = timeVal.split(':').map(Number);
                const tz = document.getElementById("timezoneSelect").value || selectedTz;

                const utcData = await getUTCFromLocal(year, month, day, hour, minute, tz);
                const swe = await initSwissEph();
                const jd = swe.julday(utcData.year, utcData.month, utcData.day, utcData.hour, 1);

                const positions = await calculatePositions(jd, selectedLat, selectedLon);
                const cusps = await calculateHouses(jd, selectedLat, selectedLon);
                const aspects = calculateAspects(positions);

                const svgContainer = document.getElementById("natalChart");
                svgContainer.innerHTML = "";
                const newSVG = createSVGChart(positions, cusps);
                svgContainer.appendChild(newSVG);

                renderTables(positions, cusps, aspects);

            } catch (e) {
                console.error(e);
                errorEl.textContent = e.message || "Hesaplama hatasƒ±";
                errorEl.style.display = "block";
            }
        }

        async function searchNominatim(query) {
            if (query.length < 3) return [];
            const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=8&addressdetails=1&accept-language=tr`;
            const res = await fetch(url, { headers: { 'User-Agent': 'NatalChartDemo/2.0' } });
            return await res.json();
        }

        function debounceSearch() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(async () => {
                const q = document.getElementById("locationSearch").value.trim();
                const resultsDiv = document.getElementById("locationResults");
                resultsDiv.innerHTML = "";
                if (q.length < 3) return;
                const places = await searchNominatim(q);
                places.forEach(place => {
                    const lat = parseFloat(place.lat);
                    const lon = parseFloat(place.lon);
                    const name = place.display_name || `${place.name}, ${place.address?.country || ''}`;
                    const div = document.createElement("div");
                    div.className = "location-item";
                    div.textContent = name;
                    div.onclick = () => {
                        selectedLat = lat; selectedLon = lon; selectedDisplayName = name;
                        selectedTz = tzlookup(lat, lon) || "UTC";
                        document.getElementById("selectedLocation").textContent = name;
                        document.getElementById("latLon").value = `${lat.toFixed(4)}¬∞ / ${lon.toFixed(4)}¬∞`;
                        const tzSel = document.getElementById("timezoneSelect");
                        if (!Array.from(tzSel.options).some(o => o.value === selectedTz)) {
                            const opt = new Option(selectedTz, selectedTz); tzSel.add(opt);
                        }
                        tzSel.value = selectedTz;
                        resultsDiv.innerHTML = ""; document.getElementById("locationSearch").value = "";
                        calculateChart();
                    };
                    resultsDiv.appendChild(div);
                });
            }, 380);
        }

        function setupAutoCalculate() {
            ["birthDate","birthTime","timezoneSelect"].forEach(id => {
                document.getElementById(id).addEventListener("change", () => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(calculateChart, 550);
                });
            });
            document.getElementById("locationSearch").addEventListener("input", debounceSearch);
        }

        async function initUI() {
            const tzSel = document.getElementById("timezoneSelect");
            COMMON_TZ.forEach(tz => { const o = new Option(tz, tz); tzSel.add(o); });
            tzSel.value = "Europe/Istanbul";

            await initSwissEph();
            setupAutoCalculate();
            calculateChart();
        }

        window.onload = initUI;
        window.calculateChart = calculateChart;
    </script>
</body>
</html>

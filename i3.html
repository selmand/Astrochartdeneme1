<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Natal Chart Demo (Browser Only)</title>
  <style>
    :root { --fg:#111; --muted:#666; --bg:#fff; --line:#ddd; --soft:#f7f7f7; --err:#b00020; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: var(--fg); background: var(--bg); }
    header { padding: 14px 16px; border-bottom: 1px solid var(--line); background: var(--soft); }
    header h1 { margin: 0; font-size: 16px; font-weight: 700; }
    header .note { margin-top: 6px; color: var(--muted); font-size: 12px; }
    main { padding: 16px; display: grid; gap: 14px; grid-template-columns: 380px 1fr; align-items: start; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .card { border: 1px solid var(--line); border-radius: 10px; overflow: hidden; }
    .card .hd { padding: 10px 12px; font-weight: 700; background: var(--soft); border-bottom: 1px solid var(--line); }
    .card .bd { padding: 12px; }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid .full { grid-column: 1 / -1; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    input, select, button {
      width: 100%; box-sizing: border-box; padding: 9px 10px; border: 1px solid var(--line);
      border-radius: 8px; font-size: 14px; background: #fff;
    }
    input[readonly] { background: #fafafa; color: #333; }
    button { cursor: pointer; font-weight: 700; }
    .tiny { font-size: 12px; color: var(--muted); }
    .warn { color: #8a5a00; background: #fff7e6; border: 1px solid #ffd27d; padding: 10px; border-radius: 10px; }
    .error { color: #fff; background: var(--err); padding: 10px; border-radius: 10px; }
    .ok { color: #0a6; background: #eafff2; border: 1px solid #b5f0cf; padding: 10px; border-radius: 10px; }
    .pill { display: inline-block; padding: 3px 8px; border-radius: 999px; border: 1px solid var(--line); background: #fff; font-size: 12px; color: var(--muted); }

    .autocomplete { position: relative; }
    .results {
      position: absolute; z-index: 20; left: 0; right: 0; top: calc(100% + 6px);
      border: 1px solid var(--line); border-radius: 10px; background: #fff; overflow: hidden;
      box-shadow: 0 12px 30px rgba(0,0,0,.08);
      max-height: 260px; overflow-y: auto;
    }
    .results button {
      width: 100%; text-align: left; border: 0; border-bottom: 1px solid #eee;
      padding: 10px 12px; background: #fff; border-radius: 0; font-weight: 600;
    }
    .results button:hover { background: #f6f6f6; }
    .results button:last-child { border-bottom: 0; }

    .split { display: grid; grid-template-columns: 520px 1fr; gap: 14px; }
    @media (max-width: 1200px) { .split { grid-template-columns: 1fr; } }

    .svgWrap { display: grid; place-items: center; padding: 12px; }
    svg { max-width: 100%; height: auto; }
    .tables { display: grid; gap: 14px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { border: 1px solid var(--line); padding: 6px 8px; vertical-align: top; }
    th { background: var(--soft); text-align: left; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .center { text-align: center; }
    .muted { color: var(--muted); }
    .small { font-size: 12px; }
    .aspectCell { white-space: nowrap; text-align: center; }
    .footerline { margin-top: 8px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>Natal Chart Demo (tek dosya, sadece tarayıcı)</h1>
    <div class="note">Nasıl çalıştırılır: Bu dosyayı <span class="mono">index1.html</span> olarak kaydet, GitHub Pages/HTTP üzerinden aç. İnternet şart (CDN + Nominatim + WASM). Backend yok.</div>
  </header>

  <main>
    <section class="card">
      <div class="hd">Girdi</div>
      <div class="bd">
        <div id="statusBox" class="tiny"></div>

        <div class="grid" style="margin-top:10px;">
          <div>
            <label>Tarih</label>
            <input id="dateInput" type="date" />
            <div class="tiny" id="datePretty"></div>
          </div>
          <div>
            <label>Saat (24 saat)</label>
            <input id="timeInput" type="time" step="60" />
          </div>

          <div class="full autocomplete">
            <label>Lokasyon (şehir/ülke ara)</label>
            <input id="locInput" placeholder="İstanbul, Türkiye" autocomplete="off" />
            <div id="locResults" class="results" style="display:none;"></div>
            <div class="tiny" style="margin-top:6px;">Geocoding: Nominatim (OpenStreetMap) • min 3 karakter • debounce + cache</div>
          </div>

          <div>
            <label>Enlem (lat)</label>
            <input id="latInput" readonly />
          </div>
          <div>
            <label>Boylam (lon)</label>
            <input id="lonInput" readonly />
          </div>

          <div class="full">
            <label>Timezone (IANA)</label>
            <select id="tzSelect"></select>
            <div class="tiny" style="margin-top:6px;">Lokasyondan otomatik (tz-lookup). İstersen elle değiştir.</div>
          </div>

          <div class="full" id="dstBox" style="display:none;"></div>

          <div class="full">
            <button id="calcBtn">Hesapla</button>
            <div class="tiny" style="margin-top:8px;">
              Ev sistemi: <span class="pill">Placidus</span>
              <span style="margin-left:10px" class="muted">Otomatik güncelleme: input değişince debounce ile yeniden hesaplar.</span>
            </div>
          </div>

          <div class="full">
            <div class="card" style="border-radius:10px;">
              <div class="hd">Seçilen Lokasyon Özeti</div>
              <div class="bd">
                <div class="small"><span class="muted">Ad:</span> <span id="locName">—</span></div>
                <div class="small"><span class="muted">Lat/Lon:</span> <span id="locLatLon">—</span></div>
                <div class="small"><span class="muted">Timezone:</span> <span id="locTz">—</span></div>
                <div class="small"><span class="muted">Local → UTC:</span> <span id="locUtc">—</span></div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </section>

    <section class="card">
      <div class="hd">Çıktı</div>
      <div class="bd">
        <div class="split">
          <div class="card">
            <div class="hd">Natal Chart Wheel (SVG)</div>
            <div class="bd svgWrap">
              <div id="chartWrap"></div>
              <div class="footerline">Gezegenler iç halka • Ev çizgileri Placidus cusp • ASC/DSC/MC/IC etiketli • Aspekt çizgileri merkezde</div>
            </div>
          </div>

          <div class="tables">
            <div class="card">
              <div class="hd">Gezegen / Nokta Konumları</div>
              <div class="bd">
                <div class="tiny" id="engineInfo"></div>
                <div style="overflow:auto; margin-top:8px;">
                  <table id="planetTable">
                    <thead>
                      <tr>
                        <th>Body</th>
                        <th>Lon (0–360)</th>
                        <th>Burç</th>
                        <th>Derece</th>
                        <th>R</th>
                        <th class="center">Ev</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Ev Cusp (Placidus)</div>
              <div class="bd" style="overflow:auto;">
                <table id="houseTable">
                  <thead>
                    <tr>
                      <th>Ev</th>
                      <th>Burç</th>
                      <th>Derece</th>
                      <th>Lon (0–360)</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
                <div class="tiny" style="margin-top:6px;">ASC ve MC ayrıca chart üzerinde işaretli.</div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Açı Listesi (Majör)</div>
              <div class="bd" style="overflow:auto;">
                <table id="aspectList">
                  <thead>
                    <tr>
                      <th>Body A</th>
                      <th>Body B</th>
                      <th>Açı</th>
                      <th>Orb</th>
                      <th>Applying/Separating</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
                <div class="tiny" style="margin-top:6px;">Orb: Güneş/Ay 8° • Diğerleri + Node 6°</div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Açı Tablosu (Matrix)</div>
              <div class="bd" style="overflow:auto;">
                <table id="aspectMatrix"></table>
              </div>
            </div>
          </div>
        </div>

      </div>
    </section>
  </main>

  <script type="module">
    const $ = (sel) => document.querySelector(sel);
    const pad2 = (n) => String(n).padStart(2, "0");
    const deg2rad = (d) => (d * Math.PI) / 180;
    const norm360 = (d) => ((d % 360) + 360) % 360;
    const norm180 = (d) => {
      let x = ((d % 360) + 360) % 360;
      if (x > 180) x -= 360;
      return x;
    };
    const fmtDMS = (deg) => {
      const d = norm360(deg);
      const signIndex = Math.floor(d / 30);
      const signDeg = d - signIndex * 30;
      const dd = Math.floor(signDeg);
      const mmFloat = (signDeg - dd) * 60;
      const mm = Math.floor(mmFloat);
      const ss = Math.floor((mmFloat - mm) * 60);
      return { signIndex, dd, mm, ss };
    };
    const orbToText = (orbDeg) => {
      const a = Math.abs(orbDeg);
      const d = Math.floor(a);
      const m = Math.floor((a - d) * 60);
      return `${d}°${pad2(m)}′`;
    };
    const debounce = (fn, wait=350) => {
      let t = null;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
    };
    const isSupportedIana = (tz) => {
      try { new Intl.DateTimeFormat("en-US", { timeZone: tz }).format(new Date()); return true; }
      catch { return false; }
    };

    // Temporal polyfill (iOS Safari'de global Temporal bazen yok ya da yarım yamalak)
    import { Temporal as TemporalPoly } from "https://cdn.jsdelivr.net/npm/@js-temporal/polyfill@0.5.1/+esm";
    globalThis.Temporal = TemporalPoly;           // overwrite (güvenli)
    const Temporal = TemporalPoly;               // local binding (module-scope garanti)

    import tzLookup from "https://cdn.jsdelivr.net/npm/tz-lookup@6.1.25/+esm";
    import SwissEPH from "https://cdn.jsdelivr.net/npm/sweph-wasm@2.6.9/dist/index.js";

    const SIGNS = [
      { name:"Koç", sym:"♈" }, { name:"Boğa", sym:"♉" }, { name:"İkizler", sym:"♊" }, { name:"Yengeç", sym:"♋" },
      { name:"Aslan", sym:"♌" }, { name:"Başak", sym:"♍" }, { name:"Terazi", sym:"♎" }, { name:"Akrep", sym:"♏" },
      { name:"Yay", sym:"♐" }, { name:"Oğlak", sym:"♑" }, { name:"Kova", sym:"♒" }, { name:"Balık", sym:"♓" }
    ];

    const BODIES = [
      { key:"Sun",    label:"Güneş",   glyph:"☉", seKey:"SE_SUN" },
      { key:"Moon",   label:"Ay",      glyph:"☽", seKey:"SE_MOON" },
      { key:"Mercury",label:"Merkür",  glyph:"☿", seKey:"SE_MERCURY" },
      { key:"Venus",  label:"Venüs",   glyph:"♀", seKey:"SE_VENUS" },
      { key:"Mars",   label:"Mars",    glyph:"♂", seKey:"SE_MARS" },
      { key:"Jupiter",label:"Jüpiter", glyph:"♃", seKey:"SE_JUPITER" },
      { key:"Saturn", label:"Satürn",  glyph:"♄", seKey:"SE_SATURN" },
      { key:"Uranus", label:"Uranüs",  glyph:"♅", seKey:"SE_URANUS" },
      { key:"Neptune",label:"Neptün",  glyph:"♆", seKey:"SE_NEPTUNE" },
      { key:"Pluto",  label:"Plüton",  glyph:"♇", seKey:"SE_PLUTO" },
      { key:"Node",   label:"True Node", glyph:"☊", seKey:"SE_TRUE_NODE" },
    ];

    const ASPECTS = [
      { name:"Kavuşum", angle:0,   sym:"☌" },
      { name:"Sekstil", angle:60,  sym:"✶" },
      { name:"Kare",    angle:90,  sym:"□" },
      { name:"Üçgen",   angle:120, sym:"△" },
      { name:"Karşıt",  angle:180, sym:"☍" }
    ];

    class NominatimService {
      constructor() { this.cache = new Map(); this.inflight = new Map(); }
      async search(q) {
        const query = (q || "").trim();
        if (query.length < 3) return [];
        const key = query.toLowerCase();
        if (this.cache.has(key)) return this.cache.get(key);
        if (this.inflight.has(key)) return this.inflight.get(key);

        const url = new URL("https://nominatim.openstreetmap.org/search");
        url.searchParams.set("format", "jsonv2");
        url.searchParams.set("addressdetails", "1");
        url.searchParams.set("limit", "7");
        url.searchParams.set("q", query);

        const p = fetch(url.toString(), { headers: { "Accept":"application/json", "Accept-Language":"tr" } })
          .then(r => r.json())
          .then(arr => {
            const cleaned = (arr || []).map(x => ({
              displayName: x.display_name,
              lat: Number(x.lat),
              lon: Number(x.lon)
            }));
            this.cache.set(key, cleaned);
            this.inflight.delete(key);
            return cleaned;
          })
          .catch(err => { this.inflight.delete(key); throw err; });

        this.inflight.set(key, p);
        return p;
      }
    }

    class TimezoneService {
      constructor() { this.tzList = this._build(); }
      _build() {
        let list = [];
        try {
          if (Intl && typeof Intl.supportedValuesOf === "function") list = Intl.supportedValuesOf("timeZone") || [];
        } catch {}
        if (!list.length) {
          list = [
            "Europe/Istanbul","Europe/London","Europe/Paris","Europe/Berlin","Europe/Moscow",
            "America/New_York","America/Chicago","America/Denver","America/Los_Angeles",
            "America/Sao_Paulo","Asia/Dubai","Asia/Tehran","Asia/Jerusalem","Asia/Kolkata",
            "Asia/Bangkok","Asia/Singapore","Asia/Shanghai","Asia/Tokyo","Australia/Sydney",
            "Pacific/Auckland","UTC"
          ];
        }
        return list.filter(isSupportedIana);
      }
      lookup(lat, lon) {
        const tz = tzLookup(lat, lon);
        return isSupportedIana(tz) ? tz : null;
      }
    }

    class TemporalDST {
      static analyzeLocal(timeZone, y, m, d, hh, mm) {
        if (!isSupportedIana(timeZone)) throw new Error(`Timezone desteklenmiyor: ${timeZone}`);
        const tz = Temporal.TimeZone.from(timeZone);
        const pdt = new Temporal.PlainDateTime(y, m, d, hh, mm, 0, 0, 0);
        const instants = tz.getPossibleInstantsFor(pdt);
        if (instants.length === 0) return { kind:"nonexistent", instants: [] };
        if (instants.length === 2) return { kind:"ambiguous", instants };
        return { kind:"unique", instants };
      }
      static toUTCInstant(timeZone, y, m, d, hh, mm, disambiguation="later") {
        if (!isSupportedIana(timeZone)) throw new Error(`Timezone desteklenmiyor: ${timeZone}`);
        const tz = Temporal.TimeZone.from(timeZone);
        const pdt = new Temporal.PlainDateTime(y, m, d, hh, mm, 0, 0, 0);
        const zdt = pdt.toZonedDateTime({ timeZone: tz, disambiguation });
        return zdt.toInstant();
      }
      static instantToISO(instant) { return instant.toString(); }
    }

    class SwissEphEngine {
      constructor() {
        this.swe = null;
        this.ready = null;
        this.epheUrl = "https://cdn.jsdelivr.net/npm/sweph-wasm@2.6.9/dist/ephe/";
      }
      initOnce() {
        if (this.ready) return this.ready;
        this.ready = (async () => {
          const swe = await SwissEPH.init();
          this.swe = swe;
          if (typeof swe.swe_set_ephe_path === "function") await swe.swe_set_ephe_path(this.epheUrl);
          return swe;
        })();
        return this.ready;
      }
      _getConst(name, fallback) {
        const v = this.swe?.[name];
        return (typeof v === "number") ? v : fallback;
      }
      calcJulianDayUTC(y, m, d, utHours) {
        return this.swe.swe_julday(y, m, d, utHours, 1);
      }
      calcBodies(jdUT) {
        const swe = this.swe;
        const flags = (this._getConst("SEFLG_SWIEPH", 2) | this._getConst("SEFLG_SPEED", 256));
        const getId = (seKey) => {
          if (typeof swe[seKey] === "number") return swe[seKey];
          const map = { SE_SUN:0, SE_MOON:1, SE_MERCURY:2, SE_VENUS:3, SE_MARS:4, SE_JUPITER:5, SE_SATURN:6, SE_URANUS:7, SE_NEPTUNE:8, SE_PLUTO:9, SE_TRUE_NODE:11 };
          return map[seKey];
        };
        const list = [];
        for (const b of BODIES) {
          const id = getId(b.seKey);
          const res = swe.swe_calc_ut(jdUT, id, flags);
          const lon = Number(res?.[0]);
          const lonSpeed = Number(res?.[3]);
          list.push({ ...b, id, lon: norm360(lon), lonSpeed, retro: (lonSpeed < 0) });
        }
        return list;
      }
      calcHouses(jdUT, lat, lon) {
        const swe = this.swe;
        const hsys = "P";
        let out = null;
        if (typeof swe.swe_houses_ex === "function") out = swe.swe_houses_ex(jdUT, 0, lat, lon, hsys);
        else if (typeof swe.swe_houses === "function") out = swe.swe_houses(jdUT, lat, lon, hsys);
        else throw new Error("SwissEph: swe_houses(_ex) bulunamadı.");

        let cusps = null, ascmc = null;
        if (Array.isArray(out) && out.length >= 2) { cusps = out[0]; ascmc = out[1]; }
        else if (out && typeof out === "object") { cusps = out.cusps || out[0]; ascmc = out.ascmc || out[1]; }
        if (!cusps || !ascmc) throw new Error("SwissEph: ev verisi parse edilemedi.");

        const cuspArr = [];
        for (let i=1; i<=12; i++) cuspArr.push(norm360(Number(cusps[i] ?? cusps[i-1])));
        const asc = norm360(Number(ascmc[0] ?? ascmc.asc ?? ascmc.ASC ?? ascmc[0]));
        const mc  = norm360(Number(ascmc[1] ?? ascmc.mc  ?? ascmc.MC  ?? ascmc[1]));
        return { cusps: cuspArr, asc, mc };
      }
    }

    class HouseAssigner {
      static houseOfLon(lon, cuspLons) {
        const L = norm360(lon);
        for (let i=0; i<12; i++) {
          const a = cuspLons[i];
          const b = cuspLons[(i+1)%12];
          if (a <= b) { if (L >= a && L < b) return i+1; }
          else { if (L >= a || L < b) return i+1; }
        }
        return 12;
      }
    }

    class AspectCalculator {
      static _orbLimit(aKey, bKey) {
        const lum = (k) => (k === "Sun" || k === "Moon");
        return (lum(aKey) || lum(bKey)) ? 8 : 6;
      }
      static findAspects(items) {
        const aspects = [];
        for (let i=0; i<items.length; i++) {
          for (let j=i+1; j<items.length; j++) {
            const A = items[i], B = items[j];
            const d = Math.abs(norm180(B.lon - A.lon));
            for (const asp of ASPECTS) {
              const orb = Math.abs(d - asp.angle);
              if (orb <= this._orbLimit(A.key, B.key)) aspects.push({ A, B, aspect: asp, orb });
            }
          }
        }
        return aspects.sort((x,y) => x.orb - y.orb);
      }
      static applyingOrSeparating(pair) {
        const { A, B, aspect } = pair;
        const dtDays = 1/24;
        const A2 = norm360(A.lon + (A.lonSpeed || 0) * dtDays);
        const B2 = norm360(B.lon + (B.lonSpeed || 0) * dtDays);
        const d1 = Math.abs(norm180(B.lon - A.lon));
        const d2 = Math.abs(norm180(B2 - A2));
        const orb1 = Math.abs(d1 - aspect.angle);
        const orb2 = Math.abs(d2 - aspect.angle);
        return (orb2 < orb1) ? "Applying" : "Separating";
      }
      static buildMatrix(items, aspectHits) {
        const n = items.length;
        const cell = Array.from({length:n}, () => Array.from({length:n}, () => null));
        for (const hit of aspectHits) {
          const i = items.findIndex(x => x.key === hit.A.key);
          const j = items.findIndex(x => x.key === hit.B.key);
          if (i >= 0 && j >= 0) { cell[i][j] = hit; cell[j][i] = hit; }
        }
        return cell;
      }
    }

    class ChartRenderer {
      constructor(container) { this.container = container; }
      render({ houses, bodies, aspects }) {
        const size = 520;
        const cx = size/2, cy = size/2;
        const R0 = 245, Rz = 215, Rh = 195, Rp = 155, Ra = 120, Rtext = 232;

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
        svg.setAttribute("width", String(size));
        svg.setAttribute("height", String(size));

        const add = (el) => (svg.appendChild(el), el);
        const circle = (r, stroke="#bbb", fill="none", w=1) => {
          const c = document.createElementNS(svg.namespaceURI, "circle");
          c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", r);
          c.setAttribute("stroke", stroke); c.setAttribute("fill", fill); c.setAttribute("stroke-width", w);
          return c;
        };
        const line = (x1,y1,x2,y2, stroke="#bbb", w=1, dash=null) => {
          const l = document.createElementNS(svg.namespaceURI, "line");
          l.setAttribute("x1", x1); l.setAttribute("y1", y1);
          l.setAttribute("x2", x2); l.setAttribute("y2", y2);
          l.setAttribute("stroke", stroke); l.setAttribute("stroke-width", w);
          if (dash) l.setAttribute("stroke-dasharray", dash);
          return l;
        };
        const text = (x,y, str, sizePx=12, anchor="middle", weight="600") => {
          const t = document.createElementNS(svg.namespaceURI, "text");
          t.setAttribute("x", x); t.setAttribute("y", y);
          t.setAttribute("font-size", sizePx);
          t.setAttribute("text-anchor", anchor);
          t.setAttribute("dominant-baseline", "middle");
          t.setAttribute("font-weight", weight);
          t.textContent = str;
          return t;
        };
        const polar = (r, angRad) => ({ x: cx + r*Math.cos(angRad), y: cy + r*Math.sin(angRad) });
        const lonToAng = (lon) => deg2rad(norm360(lon) - 90);

        add(circle(R0, "#999", "none", 1.2));
        add(circle(Rz, "#bbb", "none", 1));
        add(circle(Rh, "#bbb", "none", 1));
        add(circle(Rp, "#ddd", "none", 1));
        add(circle(Ra, "#eee", "none", 1));

        for (let i=0;i<12;i++) {
          const start = deg2rad(i*30 - 90);
          const p1 = polar(R0, start);
          const p2 = polar(R0, start + deg2rad(30));
          const p3 = polar(Rz, start + deg2rad(30));
          const p4 = polar(Rz, start);
          const path = document.createElementNS(svg.namespaceURI, "path");
          path.setAttribute("d",
            `M ${p4.x} ${p4.y}
             L ${p1.x} ${p1.y}
             A ${R0} ${R0} 0 0 1 ${p2.x} ${p2.y}
             L ${p3.x} ${p3.y}
             A ${Rz} ${Rz} 0 0 0 ${p4.x} ${p4.y}
             Z`
          );
          path.setAttribute("fill", i%2===0 ? "#fcfcfc" : "#f5f5f5");
          path.setAttribute("stroke", "#e2e2e2");
          path.setAttribute("stroke-width", "1");
          add(path);

          const mid = start + deg2rad(15);
          const pt = polar(Rtext, mid);
          add(text(pt.x, pt.y, SIGNS[i].sym, 16, "middle", "700"));
        }

        const cuspLons = houses.cusps;
        for (let i=0;i<12;i++) {
          const ang = lonToAng(cuspLons[i]);
          const pIn = polar(Rh, ang);
          const pOut = polar(R0, ang);
          add(line(pIn.x, pIn.y, pOut.x, pOut.y, "#bdbdbd", 1));
          const labelPt = polar(Rh - 16, ang);
          add(text(labelPt.x, labelPt.y, String(i+1), 10, "middle", "700")).setAttribute("fill", "#666");
        }

        const ascAng = lonToAng(houses.asc);
        const dscAng = lonToAng(norm360(houses.asc + 180));
        const mcAng  = lonToAng(houses.mc);
        const icAng  = lonToAng(norm360(houses.mc + 180));

        const mark = (ang, label) => {
          const p1 = polar(Rh-6, ang);
          const p2 = polar(R0+2, ang);
          add(line(p1.x,p1.y,p2.x,p2.y,"#888",1.6));
          const pt = polar(R0+14, ang);
          add(text(pt.x, pt.y, label, 11, "middle", "800")).setAttribute("fill","#333");
        };
        mark(ascAng, "ASC");
        mark(dscAng, "DSC");
        mark(mcAng, "MC");
        mark(icAng, "IC");

        const aspectStyle = (name) => {
          if (name === "Kavuşum") return { w:1.2, dash:null, stroke:"#999" };
          if (name === "Karşıt")  return { w:1.2, dash:null, stroke:"#aaa" };
          if (name === "Kare")    return { w:1.1, dash:"4 3", stroke:"#aaa" };
          if (name === "Üçgen")   return { w:1.1, dash:"2 3", stroke:"#aaa" };
          if (name === "Sekstil") return { w:1.1, dash:"1 3", stroke:"#aaa" };
          return { w:1.1, dash:"2 2", stroke:"#aaa" };
        };

        const placements = bodies.map(b => ({ b, ang: lonToAng(b.lon) })).sort((x,y) => x.ang - y.ang);
        const minSep = deg2rad(7);
        for (let i=0;i<placements.length;i++) {
          let offset = 0;
          for (let j=i-1; j>=0; j--) {
            const da = Math.abs(placements[i].ang - placements[j].ang);
            if (da < minSep) offset++;
            else break;
          }
          placements[i].r = Rp - offset*14;
        }

        const aspectLines = aspects.filter(x => x.orb <= 3.0);
        for (const hit of aspectLines) {
          const pa = placements.find(p => p.b.key === hit.A.key);
          const pb = placements.find(p => p.b.key === hit.B.key);
          if (!pa || !pb) continue;
          const A = polar(Ra, pa.ang);
          const B = polar(Ra, pb.ang);
          const st = aspectStyle(hit.aspect.name);
          add(line(A.x,A.y,B.x,B.y, st.stroke, st.w, st.dash));
        }

        for (const p of placements) {
          const pt = polar(p.r, p.ang);
          add(text(pt.x, pt.y, p.b.glyph, 18, "middle", "800")).setAttribute("fill", "#111");
          const namePt = polar(p.r + 18, p.ang);
          add(text(namePt.x, namePt.y, p.b.key, 9, "middle", "600")).setAttribute("fill", "#666");
          if (p.b.retro) {
            const rPt = polar(p.r - 18, p.ang);
            add(text(rPt.x, rPt.y, "R", 10, "middle", "900")).setAttribute("fill", "#666");
          }
        }

        this.container.innerHTML = "";
        this.container.appendChild(svg);
      }
    }

    class App {
      constructor() {
        this.nominatim = new NominatimService();
        this.tzSvc = new TimezoneService();
        this.engine = new SwissEphEngine();
        this.renderer = new ChartRenderer($("#chartWrap"));
        this.state = { loc: null, tz: null, disambiguation: "later" };
        this.dom = {
          statusBox: $("#statusBox"),
          dateInput: $("#dateInput"),
          timeInput: $("#timeInput"),
          datePretty: $("#datePretty"),
          locInput: $("#locInput"),
          locResults: $("#locResults"),
          latInput: $("#latInput"),
          lonInput: $("#lonInput"),
          tzSelect: $("#tzSelect"),
          dstBox: $("#dstBox"),
          calcBtn: $("#calcBtn"),
          locName: $("#locName"),
          locLatLon: $("#locLatLon"),
          locTz: $("#locTz"),
          locUtc: $("#locUtc"),
          planetTable: $("#planetTable tbody"),
          houseTable: $("#houseTable tbody"),
          aspectList: $("#aspectList tbody"),
          aspectMatrix: $("#aspectMatrix"),
          engineInfo: $("#engineInfo")
        };
      }

      async init() {
        this._initTimeZoneDropdown();
        this._initDefaults();
        this._bindUI();

        this._setStatus("WASM yükleniyor…", "tiny");
        try {
          await this.engine.initOnce();
          this._setStatus("Hazır. Lokasyon seç → hesapla.", "ok");
          this.dom.engineInfo.textContent = "Swiss Ephemeris: WASM (sweph-wasm) • Placidus ev • Tropical zodyak";
        } catch (e) {
          console.error(e);
          this._setStatus("WASM import/init hatası. Console'a bak.", "error");
        }

        this._scheduleRecalc();
      }

      _setStatus(msg, kind="tiny") {
        const el = this.dom.statusBox;
        el.className = "";
        if (kind === "error") el.classList.add("error");
        else if (kind === "warn") el.classList.add("warn");
        else if (kind === "ok") el.classList.add("ok");
        else el.classList.add("tiny");
        el.textContent = msg || "";
      }

      _initTimeZoneDropdown() {
        const tzSel = this.dom.tzSelect;
        tzSel.innerHTML = "";
        for (const tz of this.tzSvc.tzList) {
          const opt = document.createElement("option");
          opt.value = tz;
          opt.textContent = tz;
          tzSel.appendChild(opt);
        }
      }

      _initDefaults() {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = pad2(now.getMonth()+1);
        const dd = pad2(now.getDate());
        const hh = pad2(now.getHours());
        const mi = pad2(now.getMinutes());

        this.dom.dateInput.value = `${yyyy}-${mm}-${dd}`;
        this.dom.timeInput.value = `${hh}:${mi}`;
        this._updateDatePretty();

        const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
        const fallbackTz = isSupportedIana(browserTz) ? browserTz : "UTC";
        if ([...this.dom.tzSelect.options].some(o => o.value === fallbackTz)) this.dom.tzSelect.value = fallbackTz;
        else this.dom.tzSelect.value = "UTC";

        this.state.tz = this.dom.tzSelect.value;
        this._renderLocSummary();
      }

      _bindUI() {
        const debouncedLocSearch = debounce(async () => {
          const q = this.dom.locInput.value.trim();
          if (q.length < 3) { this._hideLocResults(); return; }
          try {
            const items = await this.nominatim.search(q);
            this._showLocResults(items);
          } catch (e) {
            console.error(e);
            this._setStatus("Lokasyon araması hata verdi (Nominatim).", "warn");
            this._hideLocResults();
          }
        }, 350);

        this.dom.locInput.addEventListener("input", () => debouncedLocSearch());

        document.addEventListener("click", (ev) => {
          if (!this.dom.locInput.contains(ev.target) && !this.dom.locResults.contains(ev.target)) this._hideLocResults();
        });

        const autoRecalc = debounce(() => this._recalc(), 450);

        this.dom.dateInput.addEventListener("change", () => { this._updateDatePretty(); this._scheduleRecalc(autoRecalc); });
        this.dom.timeInput.addEventListener("change", () => { this._scheduleRecalc(autoRecalc); });
        this.dom.tzSelect.addEventListener("change", () => {
          this.state.tz = this.dom.tzSelect.value;
          this._updateDSTBox();
          this._scheduleRecalc(autoRecalc);
        });
        this.dom.calcBtn.addEventListener("click", () => this._recalc());
      }

      _updateDatePretty() {
        const v = this.dom.dateInput.value;
        const m = v.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        this.dom.datePretty.textContent = m ? `gün/ay/yıl: ${m[3]}/${m[2]}/${m[1]}` : "";
      }

      _scheduleRecalc(fn) { (fn || debounce(() => this._recalc(), 450))(); }

      _showLocResults(items) {
        const box = this.dom.locResults;
        box.innerHTML = "";
        if (!items.length) {
          const div = document.createElement("div");
          div.style.padding = "10px 12px";
          div.className = "tiny";
          div.textContent = "Sonuç yok.";
          box.appendChild(div);
        } else {
          for (const it of items) {
            const b = document.createElement("button");
            b.type = "button";
            b.textContent = it.displayName;
            b.addEventListener("click", () => { this._selectLocation(it); this._hideLocResults(); });
            box.appendChild(b);
          }
        }
        box.style.display = "block";
      }

      _hideLocResults() { this.dom.locResults.style.display = "none"; }

      _selectLocation(it) {
        this.state.loc = { ...it };
        this.dom.locInput.value = it.displayName;
        this.dom.latInput.value = String(it.lat);
        this.dom.lonInput.value = String(it.lon);

        let tz = null;
        try { tz = this.tzSvc.lookup(it.lat, it.lon); } catch (e) { console.error(e); }

        if (tz) {
          this.state.tz = tz;
          if ([...this.dom.tzSelect.options].some(o => o.value === tz)) {
            this.dom.tzSelect.value = tz;
          } else {
            const opt = document.createElement("option");
            opt.value = tz;
            opt.textContent = tz;
            this.dom.tzSelect.appendChild(opt);
            this.dom.tzSelect.value = tz;
          }
        } else {
          this._setStatus("Timezone otomatik bulunamadı. Dropdown’dan elle seç.", "warn");
        }

        this._updateDSTBox();
        this._renderLocSummary();
        this._scheduleRecalc();
      }

      _parseInputs() {
        const d = this.dom.dateInput.value.trim();
        const t = this.dom.timeInput.value.trim();
        const tz = this.state.tz || this.dom.tzSelect.value;

        const md = d.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        const mt = t.match(/^(\d{2}):(\d{2})$/);
        if (!md) throw new Error("Tarih seç (date picker).");
        if (!mt) throw new Error("Saat seç (time picker).");
        if (!tz) throw new Error("Timezone yok.");
        if (!isSupportedIana(tz)) throw new Error(`Timezone desteklenmiyor: ${tz}`);

        return {
          year: Number(md[1]),
          month: Number(md[2]),
          day: Number(md[3]),
          hour: Number(mt[1]),
          minute: Number(mt[2]),
          tz
        };
      }

      _updateDSTBox() {
        const box = this.dom.dstBox;
        box.style.display = "none";
        box.innerHTML = "";

        let parsed;
        try { parsed = this._parseInputs(); } catch { return; }

        const { year, month, day, hour, minute, tz } = parsed;

        let info;
        try { info = TemporalDST.analyzeLocal(tz, year, month, day, hour, minute); }
        catch (e) {
          console.error(e);
          box.style.display = "block";
          const w = document.createElement("div");
          w.className = "warn";
          w.textContent = `DST kontrolü yapılamadı: ${e.message || e}`;
          box.appendChild(w);
          return;
        }

        if (info.kind === "unique") { this.state.disambiguation = "later"; return; }

        box.style.display = "block";
        const wrap = document.createElement("div");
        wrap.className = "warn";

        if (info.kind === "nonexistent") {
          wrap.innerHTML = `
            <div style="font-weight:800;margin-bottom:6px;">DST: Bu yerel saat yok (ileri atlama / gap).</div>
            <div class="small">Varsayılan: <b>later</b> (bir sonraki geçerli zamana kaydırma).</div>
          `;
          this.state.disambiguation = "later";
        }

        if (info.kind === "ambiguous") {
          const earlier = info.instants[0];
          const later   = info.instants[1];
          const earlierISO = TemporalDST.instantToISO(earlier);
          const laterISO = TemporalDST.instantToISO(later);

          wrap.innerHTML = `
            <div style="font-weight:800;margin-bottom:6px;">DST: Bu yerel saat iki kez yaşanıyor (ambiguous / fold).</div>
            <div class="small">Varsayılan: <b>later offset</b>. İstersen diğerini seç.</div>
            <div style="margin-top:10px; display:grid; gap:8px;">
              <label class="small"><input type="radio" name="dstPick" value="earlier"> Earlier offset (UTC: <span class="mono">${earlierISO}</span>)</label>
              <label class="small"><input type="radio" name="dstPick" value="later" checked> Later offset (UTC: <span class="mono">${laterISO}</span>)</label>
            </div>
          `;

          setTimeout(() => {
            const radios = box.querySelectorAll('input[name="dstPick"]');
            radios.forEach(r => r.addEventListener("change", () => {
              this.state.disambiguation = r.value;
              this._renderLocSummary();
              this._scheduleRecalc();
            }));
          }, 0);

          this.state.disambiguation = "later";
        }

        box.appendChild(wrap);
      }

      _renderLocSummary() {
        const loc = this.state.loc;
        const tz = this.state.tz || this.dom.tzSelect.value;

        this.dom.locName.textContent = loc?.displayName || "—";
        this.dom.locLatLon.textContent = (loc ? `${loc.lat.toFixed(6)}, ${loc.lon.toFixed(6)}` : "—");
        this.dom.locTz.textContent = tz || "—";

        try {
          const { year, month, day, hour, minute } = this._parseInputs();
          const inst = TemporalDST.toUTCInstant(tz, year, month, day, hour, minute, this.state.disambiguation || "later");
          this.dom.locUtc.textContent = TemporalDST.instantToISO(inst);
        } catch {
          this.dom.locUtc.textContent = "—";
        }
      }

      async _recalc() {
        if (!this.engine.ready) { this._setStatus("WASM henüz hazır değil.", "warn"); return; }

        let parsed;
        try { parsed = this._parseInputs(); }
        catch (e) { this._setStatus(e.message, "warn"); return; }

        const loc = this.state.loc;
        if (!loc) { this._setStatus("Lokasyon seçilmedi. Arama kutusundan bir yer seç.", "warn"); return; }

        const { year, month, day, hour, minute, tz } = parsed;

        this._updateDSTBox();

        let instant;
        try {
          instant = TemporalDST.toUTCInstant(tz, year, month, day, hour, minute, this.state.disambiguation || "later");
        } catch (e) {
          console.error(e);
          this._setStatus(`Timezone/Temporal dönüşümü hata verdi: ${e.message || e}`, "error");
          return;
        }

        this._renderLocSummary();

        const zdtUTC = instant.toZonedDateTimeISO("UTC");
        const y = zdtUTC.year, m = zdtUTC.month, d = zdtUTC.day;
        const utHours = zdtUTC.hour + zdtUTC.minute/60 + zdtUTC.second/3600;

        this._setStatus("Hesaplanıyor…", "tiny");
        try {
          await this.engine.initOnce();

          const jdUT = this.engine.calcJulianDayUTC(y, m, d, utHours);
          const houses = this.engine.calcHouses(jdUT, loc.lat, loc.lon);
          const bodies = this.engine.calcBodies(jdUT);

          for (const b of bodies) b.house = HouseAssigner.houseOfLon(b.lon, houses.cusps);

          const aspects = AspectCalculator.findAspects(bodies);

          this._renderPlanetTable(bodies);
          this._renderHouseTable(houses);
          this._renderAspectList(aspects);
          this._renderAspectMatrix(bodies, aspects);
          this.renderer.render({ houses, bodies, aspects });

          this._setStatus("Tamam.", "ok");
        } catch (e) {
          console.error(e);
          this._setStatus(`Hesaplama hatası: ${e.message || e}`, "error");
        }
      }

      _renderPlanetTable(bodies) {
        const tb = this.dom.planetTable;
        tb.innerHTML = "";
        for (const b of bodies) {
          const dms = fmtDMS(b.lon);
          const sign = SIGNS[dms.signIndex];
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td><span class="mono">${b.glyph}</span> ${b.label}</td>
            <td class="mono">${b.lon.toFixed(6)}</td>
            <td>${sign.sym} ${sign.name}</td>
            <td class="mono">${pad2(dms.dd)}°${pad2(dms.mm)}′${pad2(dms.ss)}″</td>
            <td class="center mono">${b.retro ? "R" : ""}</td>
            <td class="center mono">${b.house}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderHouseTable(houses) {
        const tb = this.dom.houseTable;
        tb.innerHTML = "";
        for (let i=0; i<12; i++) {
          const lon = houses.cusps[i];
          const dms = fmtDMS(lon);
          const sign = SIGNS[dms.signIndex];
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td class="center mono">${i+1}</td>
            <td>${sign.sym} ${sign.name}</td>
            <td class="mono">${pad2(dms.dd)}°${pad2(dms.mm)}′${pad2(dms.ss)}″</td>
            <td class="mono">${lon.toFixed(6)}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderAspectList(aspects) {
        const tb = this.dom.aspectList;
        tb.innerHTML = "";
        for (const a of aspects) {
          const appsep = AspectCalculator.applyingOrSeparating(a);
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${a.A.label}</td>
            <td>${a.B.label}</td>
            <td class="mono">${a.aspect.sym} ${a.aspect.name} (${a.aspect.angle}°)</td>
            <td class="mono">${orbToText(a.orb)}</td>
            <td class="mono">${appsep}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderAspectMatrix(bodies, aspects) {
        const tbl = this.dom.aspectMatrix;
        tbl.innerHTML = "";

        const hits = AspectCalculator.buildMatrix(bodies, aspects);

        const thead = document.createElement("thead");
        const hrow = document.createElement("tr");
        hrow.appendChild(Object.assign(document.createElement("th"), { textContent: "" }));
        for (const b of bodies) {
          const th = document.createElement("th");
          th.className = "aspectCell";
          th.innerHTML = `<span class="mono">${b.glyph}</span><div class="small muted">${b.key}</div>`;
          hrow.appendChild(th);
        }
        thead.appendChild(hrow);
        tbl.appendChild(thead);

        const tbody = document.createElement("tbody");
        for (let i=0;i<bodies.length;i++) {
          const tr = document.createElement("tr");
          const rowH = document.createElement("th");
          rowH.className = "aspectCell";
          rowH.innerHTML = `<span class="mono">${bodies[i].glyph}</span><div class="small muted">${bodies[i].key}</div>`;
          tr.appendChild(rowH);

          for (let j=0;j<bodies.length;j++) {
            const td = document.createElement("td");
            td.className = "aspectCell";
            if (i === j) { td.textContent = "—"; td.classList.add("muted"); }
            else {
              const hit = hits[i][j];
              if (hit) td.innerHTML = `<span class="mono">${hit.aspect.sym}</span> <span class="mono">${orbToText(hit.orb)}</span>`;
              else td.textContent = "";
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        tbl.appendChild(tbody);
      }
    }

    const app = new App();
    (async () => {
      try {
        await app.init();
      } catch (err) {
        console.error(err);
      }
    })();
  </script>
</body>
</html>

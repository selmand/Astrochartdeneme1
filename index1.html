<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Natal Chart Demo (Browser Only)</title>
  <style>
    :root { --fg:#111; --muted:#666; --bg:#fff; --line:#ddd; --soft:#f7f7f7; --err:#b00020; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: var(--fg); background: var(--bg); }
    header { padding: 14px 16px; border-bottom: 1px solid var(--line); background: var(--soft); }
    header h1 { margin: 0; font-size: 16px; font-weight: 700; }
    header .note { margin-top: 6px; color: var(--muted); font-size: 12px; }
    main { padding: 16px; display: grid; gap: 14px; grid-template-columns: 380px 1fr; align-items: start; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .card { border: 1px solid var(--line); border-radius: 10px; overflow: hidden; }
    .card .hd { padding: 10px 12px; font-weight: 700; background: var(--soft); border-bottom: 1px solid var(--line); }
    .card .bd { padding: 12px; }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid .full { grid-column: 1 / -1; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    input, select, button, textarea {
      width: 100%; box-sizing: border-box; padding: 9px 10px; border: 1px solid var(--line);
      border-radius: 8px; font-size: 14px; background: #fff;
    }
    input[readonly] { background: #fafafa; color: #333; }
    button { cursor: pointer; font-weight: 700; }
    .row { display: flex; gap: 10px; align-items: center; }
    .row > * { flex: 1; }
    .tiny { font-size: 12px; color: var(--muted); }
    .warn { color: #8a5a00; background: #fff7e6; border: 1px solid #ffd27d; padding: 10px; border-radius: 10px; }
    .error { color: #fff; background: var(--err); padding: 10px; border-radius: 10px; }
    .ok { color: #0a6; background: #eafff2; border: 1px solid #b5f0cf; padding: 10px; border-radius: 10px; }
    .pill { display: inline-block; padding: 3px 8px; border-radius: 999px; border: 1px solid var(--line); background: #fff; font-size: 12px; color: var(--muted); }

    .autocomplete { position: relative; }
    .results {
      position: absolute; z-index: 20; left: 0; right: 0; top: calc(100% + 6px);
      border: 1px solid var(--line); border-radius: 10px; background: #fff; overflow: hidden;
      box-shadow: 0 12px 30px rgba(0,0,0,.08);
      max-height: 260px; overflow-y: auto;
    }
    .results button {
      width: 100%; text-align: left; border: 0; border-bottom: 1px solid #eee;
      padding: 10px 12px; background: #fff; border-radius: 0; font-weight: 600;
    }
    .results button:hover { background: #f6f6f6; }
    .results button:last-child { border-bottom: 0; }

    .split { display: grid; grid-template-columns: 520px 1fr; gap: 14px; }
    @media (max-width: 1200px) { .split { grid-template-columns: 1fr; } }

    .svgWrap { display: grid; place-items: center; padding: 12px; }
    svg { max-width: 100%; height: auto; }
    .tables { display: grid; gap: 14px; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { border: 1px solid var(--line); padding: 6px 8px; vertical-align: top; }
    th { background: var(--soft); text-align: left; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .center { text-align: center; }
    .right { text-align: right; }
    .muted { color: var(--muted); }
    .small { font-size: 12px; }
    .aspectCell { white-space: nowrap; text-align: center; }
    .footerline { margin-top: 8px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>Natal Chart Demo (tek dosya, sadece tarayıcı)</h1>
    <div class="note">Nasıl çalıştırılır: Bu dosyayı <span class="mono">index.html</span> olarak kaydet, çift tıkla aç. İnternet şart (CDN + Nominatim + WASM). Backend yok.</div>
  </header>

  <main>
    <section class="card">
      <div class="hd">Girdi</div>
      <div class="bd">
        <div id="statusBox" class="tiny"></div>

        <div class="grid" style="margin-top:10px;">
          <div>
            <label>Tarih (gün/ay/yıl)</label>
            <input id="dateInput" placeholder="31/12/1999" inputmode="numeric" />
          </div>
          <div>
            <label>Saat (24 saat, saat:dakika)</label>
            <input id="timeInput" placeholder="23:59" inputmode="numeric" />
          </div>

          <div class="full autocomplete">
            <label>Lokasyon (şehir/ülke ara)</label>
            <input id="locInput" placeholder="İstanbul, Türkiye" autocomplete="off" />
            <div id="locResults" class="results" style="display:none;"></div>
            <div class="tiny" style="margin-top:6px;">Geocoding: Nominatim (OpenStreetMap) • min 3 karakter • debounce + cache</div>
          </div>

          <div>
            <label>Enlem (lat)</label>
            <input id="latInput" readonly />
          </div>
          <div>
            <label>Boylam (lon)</label>
            <input id="lonInput" readonly />
          </div>

          <div class="full">
            <label>Timezone (IANA)</label>
            <select id="tzSelect"></select>
            <div class="tiny" style="margin-top:6px;">Lokasyondan otomatik (tz-lookup). İstersen elle değiştir.</div>
          </div>

          <div class="full" id="dstBox" style="display:none;"></div>

          <div class="full">
            <button id="calcBtn">Hesapla</button>
            <div class="tiny" style="margin-top:8px;">
              Ev sistemi: <span class="pill">Placidus</span>
              <span style="margin-left:10px" class="muted">Otomatik güncelleme: input değişince debounce ile yeniden hesaplar.</span>
            </div>
          </div>

          <div class="full">
            <div class="card" style="border-radius:10px;">
              <div class="hd">Seçilen Lokasyon Özeti</div>
              <div class="bd">
                <div class="small"><span class="muted">Ad:</span> <span id="locName">—</span></div>
                <div class="small"><span class="muted">Lat/Lon:</span> <span id="locLatLon">—</span></div>
                <div class="small"><span class="muted">Timezone:</span> <span id="locTz">—</span></div>
                <div class="small"><span class="muted">Local → UTC:</span> <span id="locUtc">—</span></div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </section>

    <section class="card">
      <div class="hd">Çıktı</div>
      <div class="bd">
        <div class="split">
          <div class="card">
            <div class="hd">Natal Chart Wheel (SVG)</div>
            <div class="bd svgWrap">
              <div id="chartWrap"></div>
              <div class="footerline">Gezegenler iç halka • Ev çizgileri Placidus cusp • ASC/DSC/MC/IC etiketli • Aspekt çizgileri merkezde</div>
            </div>
          </div>

          <div class="tables">
            <div class="card">
              <div class="hd">Gezegen / Nokta Konumları</div>
              <div class="bd">
                <div class="tiny" id="engineInfo"></div>
                <div style="overflow:auto; margin-top:8px;">
                  <table id="planetTable">
                    <thead>
                      <tr>
                        <th>Body</th>
                        <th>Lon (0–360)</th>
                        <th>Burç</th>
                        <th>Derece</th>
                        <th>R</th>
                        <th class="center">Ev</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Ev Cusp (Placidus)</div>
              <div class="bd" style="overflow:auto;">
                <table id="houseTable">
                  <thead>
                    <tr>
                      <th>Ev</th>
                      <th>Burç</th>
                      <th>Derece</th>
                      <th>Lon (0–360)</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
                <div class="tiny" style="margin-top:6px;">ASC ve MC ayrıca chart üzerinde işaretli.</div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Açı Listesi (Majör)</div>
              <div class="bd" style="overflow:auto;">
                <table id="aspectList">
                  <thead>
                    <tr>
                      <th>Body A</th>
                      <th>Body B</th>
                      <th>Açı</th>
                      <th>Orb</th>
                      <th>Applying/Separating</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
                <div class="tiny" style="margin-top:6px;">Orb: Güneş/Ay 8° • Diğerleri + Node 6°</div>
              </div>
            </div>

            <div class="card">
              <div class="hd">Açı Tablosu (Matrix)</div>
              <div class="bd" style="overflow:auto;">
                <table id="aspectMatrix"></table>
              </div>
            </div>
          </div>
        </div>

      </div>
    </section>
  </main>

  <script type="module">
    // ===== Utilities =====
    const $ = (sel) => document.querySelector(sel);
    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
    const pad2 = (n) => String(n).padStart(2, "0");
    const deg2rad = (d) => (d * Math.PI) / 180;
    const rad2deg = (r) => (r * 180) / Math.PI;
    const norm360 = (d) => ((d % 360) + 360) % 360;
    const norm180 = (d) => {
      let x = ((d % 360) + 360) % 360;
      if (x > 180) x -= 360;
      return x;
    };
    const fmtDMS = (deg) => {
      const d = norm360(deg);
      const signIndex = Math.floor(d / 30);
      const signDeg = d - signIndex * 30;
      const dd = Math.floor(signDeg);
      const mmFloat = (signDeg - dd) * 60;
      const mm = Math.floor(mmFloat);
      const ss = Math.floor((mmFloat - mm) * 60);
      return { signIndex, dd, mm, ss };
    };
    const orbToText = (orbDeg) => {
      const a = Math.abs(orbDeg);
      const d = Math.floor(a);
      const m = Math.floor((a - d) * 60);
      return `${d}°${pad2(m)}′`;
    };
    const debounce = (fn, wait=350) => {
      let t = null;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    };

    // ===== External deps (CDN) =====
    // Temporal polyfill (module): we install global Temporal to use time zones + ambiguity detection.
    import { Temporal as TemporalPoly } from "https://cdn.jsdelivr.net/npm/@js-temporal/polyfill@0.5.1/+esm";
    if (!globalThis.Temporal) globalThis.Temporal = TemporalPoly;

    // tz-lookup (module): lat/lon -> IANA timezone (client-side)
    import tzLookup from "https://cdn.jsdelivr.net/npm/tz-lookup@6.1.25/+esm";

    // sweph-wasm (Swiss Ephemeris WASM wrapper)
    import SwissEPH from "https://cdn.jsdelivr.net/npm/sweph-wasm@2.6.9/dist/index.js";

    // ===== Domain constants =====
    const SIGNS = [
      { name:"Koç", sym:"♈" }, { name:"Boğa", sym:"♉" }, { name:"İkizler", sym:"♊" }, { name:"Yengeç", sym:"♋" },
      { name:"Aslan", sym:"♌" }, { name:"Başak", sym:"♍" }, { name:"Terazi", sym:"♎" }, { name:"Akrep", sym:"♏" },
      { name:"Yay", sym:"♐" }, { name:"Oğlak", sym:"♑" }, { name:"Kova", sym:"♒" }, { name:"Balık", sym:"♓" }
    ];
    const BODIES = [
      { key:"Sun",    label:"Güneş",   glyph:"☉", seKey:"SE_SUN" },
      { key:"Moon",   label:"Ay",      glyph:"☽", seKey:"SE_MOON" },
      { key:"Mercury",label:"Merkür",  glyph:"☿", seKey:"SE_MERCURY" },
      { key:"Venus",  label:"Venüs",   glyph:"♀", seKey:"SE_VENUS" },
      { key:"Mars",   label:"Mars",    glyph:"♂", seKey:"SE_MARS" },
      { key:"Jupiter",label:"Jüpiter", glyph:"♃", seKey:"SE_JUPITER" },
      { key:"Saturn", label:"Satürn",  glyph:"♄", seKey:"SE_SATURN" },
      { key:"Uranus", label:"Uranüs",  glyph:"♅", seKey:"SE_URANUS" },
      { key:"Neptune",label:"Neptün",  glyph:"♆", seKey:"SE_NEPTUNE" },
      { key:"Pluto",  label:"Plüton",  glyph:"♇", seKey:"SE_PLUTO" },
      { key:"Node",   label:"True Node", glyph:"☊", seKey:"SE_TRUE_NODE" },
      { key:"Chiron", label:"Chiron (ops.)", glyph:"⚷", seKey:"SE_CHIRON", optional:true }
    ];

    const ASPECTS = [
      { name:"Kavuşum", angle:0,   sym:"☌" },
      { name:"Sekstil", angle:60,  sym:"✶" },
      { name:"Kare",    angle:90,  sym:"□" },
      { name:"Üçgen",   angle:120, sym:"△" },
      { name:"Karşıt",  angle:180, sym:"☍" }
    ];

    // ===== Services =====
    class NominatimService {
      constructor() {
        this.cache = new Map();
        this.inflight = new Map();
      }
      async search(q) {
        const query = (q || "").trim();
        if (query.length < 3) return [];
        const key = query.toLowerCase();
        if (this.cache.has(key)) return this.cache.get(key);
        if (this.inflight.has(key)) return this.inflight.get(key);

        const url = new URL("https://nominatim.openstreetmap.org/search");
        url.searchParams.set("format", "jsonv2");
        url.searchParams.set("addressdetails", "1");
        url.searchParams.set("limit", "7");
        url.searchParams.set("q", query);

        const p = fetch(url.toString(), {
          headers: { "Accept": "application/json", "Accept-Language": "tr" }
        }).then(r => r.json())
          .then(arr => {
            const cleaned = (arr || []).map(x => ({
              displayName: x.display_name,
              lat: Number(x.lat),
              lon: Number(x.lon)
            }));
            this.cache.set(key, cleaned);
            this.inflight.delete(key);
            return cleaned;
          }).catch(err => {
            this.inflight.delete(key);
            throw err;
          });

        this.inflight.set(key, p);
        return p;
      }
    }

    class TimezoneService {
      constructor() {
        this.tzList = this._buildTimeZoneList();
      }
      _buildTimeZoneList() {
        // Prefer full IANA list if supported; otherwise a reasonable fallback.
        try {
          if (Intl && typeof Intl.supportedValuesOf === "function") {
            const tzs = Intl.supportedValuesOf("timeZone");
            if (Array.isArray(tzs) && tzs.length) return tzs;
          }
        } catch {}
        return [
          "Europe/Istanbul","Europe/London","Europe/Paris","Europe/Berlin","Europe/Moscow",
          "America/New_York","America/Chicago","America/Denver","America/Los_Angeles",
          "America/Sao_Paulo","Asia/Dubai","Asia/Tehran","Asia/Jerusalem","Asia/Kolkata",
          "Asia/Bangkok","Asia/Singapore","Asia/Shanghai","Asia/Tokyo","Australia/Sydney",
          "Pacific/Auckland","UTC"
        ];
      }
      lookup(lat, lon) {
        return tzLookup(lat, lon);
      }
    }

    class TemporalDST {
      static analyzeLocal(timeZone, y, m, d, hh, mm) {
        const tz = Temporal.TimeZone.from(timeZone);
        const pdt = new Temporal.PlainDateTime(y, m, d, hh, mm, 0, 0, 0);
        const instants = tz.getPossibleInstantsFor(pdt);
        if (instants.length === 0) {
          // Non-existent time (DST gap). Suggest "later" by using disambiguation later.
          return { kind:"nonexistent", instants: [] };
        }
        if (instants.length === 2) {
          // Ambiguous time (DST fold): earlier and later offsets exist
          return { kind:"ambiguous", instants };
        }
        return { kind:"unique", instants };
      }

      static toUTCInstant(timeZone, y, m, d, hh, mm, disambiguation="later") {
        const tz = Temporal.TimeZone.from(timeZone);
        const pdt = new Temporal.PlainDateTime(y, m, d, hh, mm, 0, 0, 0);
        const zdt = pdt.toZonedDateTime({ timeZone: tz, disambiguation });
        return zdt.toInstant();
      }

      static instantToISO(instant) {
        // ISO in UTC
        return instant.toString(); // ends with Z
      }
    }

    class SwissEphEngine {
      constructor() {
        this.swe = null;
        this.ready = null;
        this.epheUrl = "https://cdn.jsdelivr.net/npm/sweph-wasm@2.6.9/dist/ephe/";
      }
      initOnce() {
        if (this.ready) return this.ready;
        this.ready = (async () => {
          const swe = await SwissEPH.init();
          this.swe = swe;

          // Ephemeris files (network). Library may have defaults; we pin to its own CDN path.
          if (typeof swe.swe_set_ephe_path === "function") {
            await swe.swe_set_ephe_path(this.epheUrl);
          }

          // Ensure sidereal is off (tropical). In SwissEph, default is tropical.
          return swe;
        })();
        return this.ready;
      }

      _getConst(name, fallback) {
        const v = this.swe?.[name];
        return (typeof v === "number") ? v : fallback;
      }

      calcJulianDayUTC(y, m, d, utHours) {
        // Gregorian calendar flag is 1 in Swiss Ephemeris.
        return this.swe.swe_julday(y, m, d, utHours, 1);
      }

      calcBodies(jdUT, includeChiron) {
        const swe = this.swe;
        const flags = (this._getConst("SEFLG_SWIEPH", 2) | this._getConst("SEFLG_SPEED", 256));

        const getId = (seKey) => {
          if (typeof swe[seKey] === "number") return swe[seKey];
          // Fallbacks (SwissEph standard IDs): Sun 0, Moon 1, Mercury 2, Venus 3, Mars 4, Jupiter 5, Saturn 6, Uranus 7, Neptune 8, Pluto 9
          // True Node 11, Chiron 15
          const map = { SE_SUN:0, SE_MOON:1, SE_MERCURY:2, SE_VENUS:3, SE_MARS:4, SE_JUPITER:5, SE_SATURN:6, SE_URANUS:7, SE_NEPTUNE:8, SE_PLUTO:9, SE_TRUE_NODE:11, SE_CHIRON:15 };
          return map[seKey];
        };

        const list = [];
        for (const b of BODIES) {
          if (b.optional && !includeChiron) continue;
          const id = getId(b.seKey);
          const res = swe.swe_calc_ut(jdUT, id, flags);
          // Expected: array-like [lon, lat, dist, lonSpeed, latSpeed, distSpeed] (at least lon + lonSpeed)
          const lon = Number(res?.[0]);
          const lonSpeed = Number(res?.[3]); // deg/day
          list.push({ ...b, id, lon: norm360(lon), lonSpeed, retro: (lonSpeed < 0) });
        }
        return list;
      }

      calcHouses(jdUT, lat, lon) {
        const swe = this.swe;
        const hsys = "P"; // Placidus
        // Prefer houses_ex if available
        let out = null;
        if (typeof swe.swe_houses_ex === "function") {
          out = swe.swe_houses_ex(jdUT, 0, lat, lon, hsys);
        } else if (typeof swe.swe_houses === "function") {
          out = swe.swe_houses(jdUT, lat, lon, hsys);
        } else {
          throw new Error("SwissEph: swe_houses(_ex) bulunamadı.");
        }

        // Different wrappers return different shapes.
        // Try to normalize into { cusps: number[13], ascmc: number[] }
        let cusps = null, ascmc = null;
        if (Array.isArray(out) && out.length >= 2) {
          cusps = out[0];
          ascmc = out[1];
        } else if (out && typeof out === "object") {
          cusps = out.cusps || out.houseCusps || out.cusp || out[0];
          ascmc = out.ascmc || out.ascMc || out.points || out[1];
        }

        if (!cusps || !ascmc) throw new Error("SwissEph: ev verisi parse edilemedi.");

        // cusps: index 1..12 usually; ensure array length >= 13
        const cuspArr = [];
        for (let i=1; i<=12; i++) cuspArr.push(norm360(Number(cusps[i] ?? cusps[i-1])));
        const asc = norm360(Number(ascmc[0] ?? ascmc.asc ?? ascmc.ASC ?? ascmc[0]));
        const mc  = norm360(Number(ascmc[1] ?? ascmc.mc  ?? ascmc.MC  ?? ascmc[1]));
        return { cusps: cuspArr, asc, mc };
      }
    }

    class HouseAssigner {
      // Placidus houses are not equal; correct house placement ideally needs SwissEph house position.
      // For demo: we assign by zodiacal longitude between successive cusps (cusp longitudes already reflect Placidus).
      static houseOfLon(lon, cuspLons) {
        const L = norm360(lon);
        // Build ranges starting from house 1 cusp; handle wrap for each interval.
        for (let i=0; i<12; i++) {
          const a = cuspLons[i];
          const b = cuspLons[(i+1)%12];
          if (a <= b) {
            if (L >= a && L < b) return i+1;
          } else {
            // wrap
            if (L >= a || L < b) return i+1;
          }
        }
        return 12;
      }
    }

    class AspectCalculator {
      static _orbLimit(bodyAKey, bodyBKey) {
        const lum = (k) => (k === "Sun" || k === "Moon");
        const isLum = lum(bodyAKey) || lum(bodyBKey);
        return isLum ? 8 : 6;
      }

      static findAspects(items) {
        const aspects = [];
        for (let i=0; i<items.length; i++) {
          for (let j=i+1; j<items.length; j++) {
            const A = items[i], B = items[j];
            const d = Math.abs(norm180(B.lon - A.lon)); // 0..180
            for (const asp of ASPECTS) {
              const orb = Math.abs(d - asp.angle);
              const orbLimit = this._orbLimit(A.key, B.key);
              if (orb <= orbLimit) {
                aspects.push({ A, B, aspect: asp, orb, sepDeg: d });
              }
            }
          }
        }
        return aspects.sort((x,y) => x.orb - y.orb);
      }

      static applyingOrSeparating(pair) {
        // Simple numeric approach using instantaneous speeds (deg/day) -> check if orb decreases after 1 hour.
        const { A, B, aspect } = pair;
        const dtDays = 1/24; // 1 hour
        const A2 = norm360(A.lon + (A.lonSpeed || 0) * dtDays);
        const B2 = norm360(B.lon + (B.lonSpeed || 0) * dtDays);
        const d1 = Math.abs(norm180(B.lon - A.lon));
        const d2 = Math.abs(norm180(B2 - A2));
        const orb1 = Math.abs(d1 - aspect.angle);
        const orb2 = Math.abs(d2 - aspect.angle);
        return (orb2 < orb1) ? "Applying" : "Separating";
      }

      static buildMatrix(items, aspectHits) {
        const n = items.length;
        const cell = Array.from({length:n}, () => Array.from({length:n}, () => null));
        for (const hit of aspectHits) {
          const i = items.findIndex(x => x.key === hit.A.key);
          const j = items.findIndex(x => x.key === hit.B.key);
          if (i >= 0 && j >= 0) {
            cell[i][j] = hit;
            cell[j][i] = hit;
          }
        }
        return cell;
      }
    }

    class ChartRenderer {
      constructor(container) {
        this.container = container;
      }

      render({ houses, bodies, aspects }) {
        const size = 520;
        const cx = size/2, cy = size/2;
        const R0 = 245;   // outer radius
        const Rz = 215;   // zodiac inner edge
        const Rh = 195;   // house ring
        const Rp = 155;   // planet ring base
        const Ra = 120;   // aspect ring
        const Rtext = 232;

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
        svg.setAttribute("width", String(size));
        svg.setAttribute("height", String(size));
        svg.setAttribute("aria-label", "Natal chart wheel");

        const add = (el) => (svg.appendChild(el), el);
        const circle = (r, stroke="#bbb", fill="none", w=1) => {
          const c = document.createElementNS(svg.namespaceURI, "circle");
          c.setAttribute("cx", cx); c.setAttribute("cy", cy);
          c.setAttribute("r", r);
          c.setAttribute("stroke", stroke);
          c.setAttribute("fill", fill);
          c.setAttribute("stroke-width", w);
          return c;
        };
        const line = (x1,y1,x2,y2, stroke="#bbb", w=1, dash=null) => {
          const l = document.createElementNS(svg.namespaceURI, "line");
          l.setAttribute("x1", x1); l.setAttribute("y1", y1);
          l.setAttribute("x2", x2); l.setAttribute("y2", y2);
          l.setAttribute("stroke", stroke);
          l.setAttribute("stroke-width", w);
          if (dash) l.setAttribute("stroke-dasharray", dash);
          return l;
        };
        const text = (x,y, str, sizePx=12, anchor="middle", weight="600") => {
          const t = document.createElementNS(svg.namespaceURI, "text");
          t.setAttribute("x", x); t.setAttribute("y", y);
          t.setAttribute("font-size", sizePx);
          t.setAttribute("text-anchor", anchor);
          t.setAttribute("dominant-baseline", "middle");
          t.setAttribute("font-weight", weight);
          t.textContent = str;
          return t;
        };
        const polar = (r, angRad) => ({ x: cx + r*Math.cos(angRad), y: cy + r*Math.sin(angRad) });
        const lonToAng = (lon) => deg2rad(norm360(lon) - 90); // 0° Aries at top

        // rings
        add(circle(R0, "#999", "none", 1.2));
        add(circle(Rz, "#bbb", "none", 1));
        add(circle(Rh, "#bbb", "none", 1));
        add(circle(Rp, "#ddd", "none", 1));
        add(circle(Ra, "#eee", "none", 1));

        // zodiac slices + symbols
        for (let i=0;i<12;i++) {
          const start = deg2rad(i*30 - 90);
          const p1 = polar(R0, start);
          const p2 = polar(R0, start + deg2rad(30));
          const p3 = polar(Rz, start + deg2rad(30));
          const p4 = polar(Rz, start);
          const path = document.createElementNS(svg.namespaceURI, "path");
          const largeArc = 0;
          path.setAttribute("d",
            `M ${p4.x} ${p4.y}
             L ${p1.x} ${p1.y}
             A ${R0} ${R0} 0 ${largeArc} 1 ${p2.x} ${p2.y}
             L ${p3.x} ${p3.y}
             A ${Rz} ${Rz} 0 ${largeArc} 0 ${p4.x} ${p4.y}
             Z`
          );
          path.setAttribute("fill", i%2===0 ? "#fcfcfc" : "#f5f5f5");
          path.setAttribute("stroke", "#e2e2e2");
          path.setAttribute("stroke-width", "1");
          add(path);

          const mid = start + deg2rad(15);
          const pt = polar(Rtext, mid);
          add(text(pt.x, pt.y, SIGNS[i].sym, 16, "middle", "700"));
        }

        // house lines (Placidus cusps)
        const cuspLons = houses.cusps;
        for (let i=0;i<12;i++) {
          const ang = lonToAng(cuspLons[i]);
          const pIn = polar(Rh, ang);
          const pOut = polar(R0, ang);
          add(line(pIn.x, pIn.y, pOut.x, pOut.y, "#bdbdbd", 1));
          const labelPt = polar(Rh - 16, ang);
          add(text(labelPt.x, labelPt.y, String(i+1), 10, "middle", "700")).setAttribute("fill", "#666");
        }

        // Asc/MC axis markers
        const ascAng = lonToAng(houses.asc);
        const dscAng = lonToAng(norm360(houses.asc + 180));
        const mcAng  = lonToAng(houses.mc);
        const icAng  = lonToAng(norm360(houses.mc + 180));

        const mark = (ang, label) => {
          const p1 = polar(Rh-6, ang);
          const p2 = polar(R0+2, ang);
          add(line(p1.x,p1.y,p2.x,p2.y,"#888",1.6));
          const pt = polar(R0+14, ang);
          add(text(pt.x, pt.y, label, 11, "middle", "800")).setAttribute("fill","#333");
        };
        mark(ascAng, "ASC");
        mark(dscAng, "DSC");
        mark(mcAng, "MC");
        mark(icAng, "IC");

        // aspect lines in center
        const aspectStyle = (name) => {
          // no forced colors; just dash styles
          if (name === "Kavuşum") return { w:1.2, dash:null, stroke:"#999" };
          if (name === "Karşıt")  return { w:1.2, dash:null, stroke:"#aaa" };
          if (name === "Kare")    return { w:1.1, dash:"4 3", stroke:"#aaa" };
          if (name === "Üçgen")   return { w:1.1, dash:"2 3", stroke:"#aaa" };
          if (name === "Sekstil") return { w:1.1, dash:"1 3", stroke:"#aaa" };
          return { w:1.1, dash:"2 2", stroke:"#aaa" };
        };

        // Planet stacking (simple radial offsets when clustered)
        const placements = bodies
          .map(b => ({ b, ang: lonToAng(b.lon) }))
          .sort((x,y) => x.ang - y.ang);

        const minSep = deg2rad(7); // radians
        for (let i=0;i<placements.length;i++) {
          let offset = 0;
          for (let j=i-1; j>=0; j--) {
            const da = Math.abs(placements[i].ang - placements[j].ang);
            if (da < minSep) offset++;
            else break;
          }
          placements[i].r = Rp - offset*14;
        }

        // aspect lines based on actual pairs present (exclude too many lines: keep orb<=3° for clarity, but still list all)
        const aspectLines = aspects.filter(x => x.orb <= 3.0);
        for (const hit of aspectLines) {
          const pa = placements.find(p => p.b.key === hit.A.key);
          const pb = placements.find(p => p.b.key === hit.B.key);
          if (!pa || !pb) continue;
          const A = polar(Ra, pa.ang);
          const B = polar(Ra, pb.ang);
          const st = aspectStyle(hit.aspect.name);
          add(line(A.x,A.y,B.x,B.y, st.stroke, st.w, st.dash));
        }

        // planet glyphs + small labels
        for (const p of placements) {
          const pt = polar(p.r, p.ang);
          const g = add(text(pt.x, pt.y, p.b.glyph, 18, "middle", "800"));
          g.setAttribute("fill", "#111");
          const namePt = polar(p.r + 18, p.ang);
          const nm = add(text(namePt.x, namePt.y, p.b.key, 9, "middle", "600"));
          nm.setAttribute("fill", "#666");
          if (p.b.retro) {
            const rPt = polar(p.r - 18, p.ang);
            const rr = add(text(rPt.x, rPt.y, "R", 10, "middle", "900"));
            rr.setAttribute("fill", "#666");
          }
        }

        this.container.innerHTML = "";
        this.container.appendChild(svg);
      }
    }

    // ===== App Controller =====
    class App {
      constructor() {
        this.nominatim = new NominatimService();
        this.tzSvc = new TimezoneService();
        this.engine = new SwissEphEngine();
        this.renderer = new ChartRenderer($("#chartWrap"));

        this.state = {
          loc: null,
          tz: null,
          disambiguation: "later", // default per requirement
          includeChiron: false
        };

        this.dom = {
          statusBox: $("#statusBox"),
          dateInput: $("#dateInput"),
          timeInput: $("#timeInput"),
          locInput: $("#locInput"),
          locResults: $("#locResults"),
          latInput: $("#latInput"),
          lonInput: $("#lonInput"),
          tzSelect: $("#tzSelect"),
          dstBox: $("#dstBox"),
          calcBtn: $("#calcBtn"),
          locName: $("#locName"),
          locLatLon: $("#locLatLon"),
          locTz: $("#locTz"),
          locUtc: $("#locUtc"),
          planetTable: $("#planetTable tbody"),
          houseTable: $("#houseTable tbody"),
          aspectList: $("#aspectList tbody"),
          aspectMatrix: $("#aspectMatrix"),
          engineInfo: $("#engineInfo")
        };
      }

      async init() {
        this._initTimeZoneDropdown();
        this._initDefaults();
        this._bindUI();

        this._setStatus("WASM yükleniyor…", "tiny");
        try {
          await this.engine.initOnce();
          this._setStatus("Hazır. Lokasyon seç → hesapla.", "ok");
          this.dom.engineInfo.textContent = "Swiss Ephemeris: WASM (sweph-wasm) • Placidus ev • Tropical zodyak";
        } catch (e) {
          console.error(e);
          this._setStatus("WASM import/init hatası. Console'a bak.", "error");
        }

        // Attempt initial compute if possible
        this._scheduleRecalc();
      }

      _initTimeZoneDropdown() {
        const tzSel = this.dom.tzSelect;
        tzSel.innerHTML = "";
        for (const tz of this.tzSvc.tzList) {
          const opt = document.createElement("option");
          opt.value = tz;
          opt.textContent = tz;
          tzSel.appendChild(opt);
        }
      }

      _initDefaults() {
        // Basic sensible defaults
        const now = new Date();
        const dd = pad2(now.getDate());
        const mm = pad2(now.getMonth()+1);
        const yy = now.getFullYear();
        const hh = pad2(now.getHours());
        const mi = pad2(now.getMinutes());

        this.dom.dateInput.value = `${dd}/${mm}/${yy}`;
        this.dom.timeInput.value = `${hh}:${mi}`;

        // If we don't have location selected, pick browser time zone as initial selection (still editable).
        const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
        if ([...this.dom.tzSelect.options].some(o => o.value === browserTz)) {
          this.dom.tzSelect.value = browserTz;
        } else {
          this.dom.tzSelect.value = "UTC";
        }
        this.state.tz = this.dom.tzSelect.value;
        this._renderLocSummary();
      }

      _bindUI() {
        const debouncedLocSearch = debounce(async () => {
          const q = this.dom.locInput.value.trim();
          if (q.length < 3) { this._hideLocResults(); return; }
          try {
            const items = await this.nominatim.search(q);
            this._showLocResults(items);
          } catch (e) {
            console.error(e);
            this._setStatus("Lokasyon araması hata verdi (Nominatim).", "warn");
            this._hideLocResults();
          }
        }, 350);

        this.dom.locInput.addEventListener("input", () => {
          debouncedLocSearch();
        });

        // Close results on outside click
        document.addEventListener("click", (ev) => {
          if (!this.dom.locInput.contains(ev.target) && !this.dom.locResults.contains(ev.target)) {
            this._hideLocResults();
          }
        });

        const autoRecalc = debounce(() => this._recalc(), 450);

        this.dom.dateInput.addEventListener("input", () => { this._scheduleRecalc(autoRecalc); });
        this.dom.timeInput.addEventListener("input", () => { this._scheduleRecalc(autoRecalc); });
        this.dom.tzSelect.addEventListener("change", () => {
          this.state.tz = this.dom.tzSelect.value;
          this._updateDSTBox();
          this._scheduleRecalc(autoRecalc);
        });

        this.dom.calcBtn.addEventListener("click", () => this._recalc());
      }

      _scheduleRecalc(fn) {
        (fn || debounce(() => this._recalc(), 450))();
      }

      _setStatus(msg, kind="tiny") {
        const el = this.dom.statusBox;
        el.className = "";
        if (kind === "error") el.classList.add("error");
        else if (kind === "warn") el.classList.add("warn");
        else if (kind === "ok") el.classList.add("ok");
        else el.classList.add("tiny");
        el.textContent = msg || "";
      }

      _showLocResults(items) {
        const box = this.dom.locResults;
        box.innerHTML = "";
        if (!items.length) {
          const div = document.createElement("div");
          div.style.padding = "10px 12px";
          div.className = "tiny";
          div.textContent = "Sonuç yok.";
          box.appendChild(div);
        } else {
          for (const it of items) {
            const b = document.createElement("button");
            b.type = "button";
            b.textContent = it.displayName;
            b.addEventListener("click", () => {
              this._selectLocation(it);
              this._hideLocResults();
            });
            box.appendChild(b);
          }
        }
        box.style.display = "block";
      }

      _hideLocResults() {
        this.dom.locResults.style.display = "none";
      }

      _selectLocation(it) {
        this.state.loc = { ...it };
        this.dom.locInput.value = it.displayName;
        this.dom.latInput.value = String(it.lat);
        this.dom.lonInput.value = String(it.lon);

        let tz = null;
        try {
          tz = this.tzSvc.lookup(it.lat, it.lon);
        } catch (e) {
          console.error(e);
          tz = null;
        }

        if (tz) {
          this.state.tz = tz;
          if ([...this.dom.tzSelect.options].some(o => o.value === tz)) {
            this.dom.tzSelect.value = tz;
          } else {
            // add if missing
            const opt = document.createElement("option");
            opt.value = tz;
            opt.textContent = tz;
            this.dom.tzSelect.appendChild(opt);
            this.dom.tzSelect.value = tz;
          }
        }

        this._updateDSTBox();
        this._renderLocSummary();
        this._scheduleRecalc();
      }

      _parseDateTimeInputs() {
        const d = this.dom.dateInput.value.trim();
        const t = this.dom.timeInput.value.trim();
        const tz = this.state.tz || this.dom.tzSelect.value;

        const m1 = d.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
        const m2 = t.match(/^(\d{1,2}):(\d{2})$/);
        if (!m1) throw new Error("Tarih formatı: gün/ay/yıl (örn 17/08/1981)");
        if (!m2) throw new Error("Saat formatı: saat:dakika (örn 03:06)");

        const day = Number(m1[1]), month = Number(m1[2]), year = Number(m1[3]);
        const hour = Number(m2[1]), minute = Number(m2[2]);
        if (!(year >= 1 && month>=1 && month<=12 && day>=1 && day<=31)) throw new Error("Tarih sayıları geçersiz.");
        if (!(hour>=0 && hour<=23 && minute>=0 && minute<=59)) throw new Error("Saat sayıları geçersiz.");

        return { year, month, day, hour, minute, tz };
      }

      _updateDSTBox() {
        const box = this.dom.dstBox;
        box.style.display = "none";
        box.innerHTML = "";

        let parsed;
        try { parsed = this._parseDateTimeInputs(); }
        catch { return; }

        const { year, month, day, hour, minute, tz } = parsed;

        let info;
        try {
          info = TemporalDST.analyzeLocal(tz, year, month, day, hour, minute);
        } catch (e) {
          console.error(e);
          return;
        }

        if (info.kind === "unique") {
          this.state.disambiguation = "later";
          box.style.display = "none";
          return;
        }

        box.style.display = "block";
        const wrap = document.createElement("div");
        wrap.className = "warn";

        if (info.kind === "nonexistent") {
          wrap.innerHTML = `
            <div style="font-weight:800;margin-bottom:6px;">DST Uyarısı: Bu yerel saat yok (DST ileri atlama / gap).</div>
            <div class="small">Varsayılan: <b>later</b> (bir sonraki geçerli zamana kaydırma). Bu durumda saat otomatik düzeltilir.</div>
          `;
          this.state.disambiguation = "later";
        }

        if (info.kind === "ambiguous") {
          const earlier = info.instants[0];
          const later   = info.instants[1];

          const mk = (inst) => TemporalDST.instantToISO(inst);
          const earlierISO = mk(earlier);
          const laterISO = mk(later);

          const row = document.createElement("div");
          row.style.marginTop = "10px";
          row.innerHTML = `
            <div style="font-weight:800;margin-bottom:6px;">DST Uyarısı: Bu yerel saat iki kez yaşanıyor (ambiguous / fold).</div>
            <div class="small">Varsayılan: <b>later offset</b>. İstersen diğerini seç.</div>
            <div style="margin-top:10px; display:grid; gap:8px;">
              <label class="small"><input type="radio" name="dstPick" value="earlier"> Earlier offset (UTC: <span class="mono">${earlierISO}</span>)</label>
              <label class="small"><input type="radio" name="dstPick" value="later" checked> Later offset (UTC: <span class="mono">${laterISO}</span>)</label>
            </div>
          `;
          wrap.appendChild(row);

          // listen
          setTimeout(() => {
            const radios = box.querySelectorAll('input[name="dstPick"]');
            radios.forEach(r => r.addEventListener("change", () => {
              this.state.disambiguation = r.value;
              this._renderLocSummary();
              this._scheduleRecalc();
            }));
          }, 0);

          this.state.disambiguation = "later";
        }

        box.appendChild(wrap);
      }

      _renderLocSummary(utcISO=null) {
        const loc = this.state.loc;
        const tz = this.state.tz || this.dom.tzSelect.value;

        this.dom.locName.textContent = loc?.displayName || "—";
        this.dom.locLatLon.textContent = (loc ? `${loc.lat.toFixed(6)}, ${loc.lon.toFixed(6)}` : "—");
        this.dom.locTz.textContent = tz || "—";

        try {
          const { year, month, day, hour, minute } = this._parseDateTimeInputs();
          const inst = TemporalDST.toUTCInstant(tz, year, month, day, hour, minute, this.state.disambiguation || "later");
          this.dom.locUtc.textContent = TemporalDST.instantToISO(inst);
        } catch {
          this.dom.locUtc.textContent = "—";
        }
      }

      async _recalc() {
        // Basic validation
        if (!this.engine.ready) {
          this._setStatus("WASM henüz hazır değil.", "warn");
          return;
        }

        let parsed;
        try {
          parsed = this._parseDateTimeInputs();
        } catch (e) {
          this._setStatus(e.message, "warn");
          return;
        }

        const loc = this.state.loc;
        if (!loc) {
          this._setStatus("Lokasyon seçilmedi. Arama kutusundan bir yer seç.", "warn");
          return;
        }

        const { year, month, day, hour, minute, tz } = parsed;

        // DST analysis + set summary
        this._updateDSTBox();

        let instant;
        try {
          instant = TemporalDST.toUTCInstant(tz, year, month, day, hour, minute, this.state.disambiguation || "later");
        } catch (e) {
          console.error(e);
          this._setStatus("Timezone/Temporal dönüşümü hata verdi. Console'a bak.", "error");
          return;
        }
        this._renderLocSummary(TemporalDST.instantToISO(instant));

        // Convert instant -> UT date components for swe_julday (needs UT decimal hours)
        const zdtUTC = instant.toZonedDateTimeISO("UTC");
        const y = zdtUTC.year, m = zdtUTC.month, d = zdtUTC.day;
        const utHours = zdtUTC.hour + zdtUTC.minute/60 + zdtUTC.second/3600;

        // Compute
        this._setStatus("Hesaplanıyor…", "tiny");
        try {
          await this.engine.initOnce();

          const jdUT = this.engine.calcJulianDayUTC(y, m, d, utHours);
          const houses = this.engine.calcHouses(jdUT, loc.lat, loc.lon);

          // bodies (include chiron optional: off by default)
          const bodies = this.engine.calcBodies(jdUT, this.state.includeChiron);

          // house assignment
          for (const b of bodies) {
            b.house = HouseAssigner.houseOfLon(b.lon, houses.cusps);
          }

          // aspects (exclude Chiron unless enabled already)
          const aspects = AspectCalculator.findAspects(bodies);

          // render tables + chart
          this._renderPlanetTable(bodies);
          this._renderHouseTable(houses);
          this._renderAspectList(aspects);
          this._renderAspectMatrix(bodies, aspects);
          this.renderer.render({ houses, bodies, aspects });

          this._setStatus("Tamam.", "ok");
        } catch (e) {
          console.error(e);
          this._setStatus(`Hesaplama hatası: ${e.message || e}`, "error");
        }
      }

      _renderPlanetTable(bodies) {
        const tb = this.dom.planetTable;
        tb.innerHTML = "";
        for (const b of bodies) {
          const dms = fmtDMS(b.lon);
          const sign = SIGNS[dms.signIndex];
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td><span class="mono">${b.glyph}</span> ${b.label}</td>
            <td class="mono">${b.lon.toFixed(6)}</td>
            <td>${sign.sym} ${sign.name}</td>
            <td class="mono">${pad2(dms.dd)}°${pad2(dms.mm)}′${pad2(dms.ss)}″</td>
            <td class="center mono">${b.retro ? "R" : ""}</td>
            <td class="center mono">${b.house}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderHouseTable(houses) {
        const tb = this.dom.houseTable;
        tb.innerHTML = "";
        for (let i=0; i<12; i++) {
          const lon = houses.cusps[i];
          const dms = fmtDMS(lon);
          const sign = SIGNS[dms.signIndex];
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td class="center mono">${i+1}</td>
            <td>${sign.sym} ${sign.name}</td>
            <td class="mono">${pad2(dms.dd)}°${pad2(dms.mm)}′${pad2(dms.ss)}″</td>
            <td class="mono">${lon.toFixed(6)}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderAspectList(aspects) {
        const tb = this.dom.aspectList;
        tb.innerHTML = "";
        for (const a of aspects) {
          const appsep = AspectCalculator.applyingOrSeparating(a);
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${a.A.label}</td>
            <td>${a.B.label}</td>
            <td class="mono">${a.aspect.sym} ${a.aspect.name} (${a.aspect.angle}°)</td>
            <td class="mono">${orbToText(a.orb)}</td>
            <td class="mono">${appsep}</td>
          `;
          tb.appendChild(tr);
        }
      }

      _renderAspectMatrix(bodies, aspects) {
        const tbl = this.dom.aspectMatrix;
        tbl.innerHTML = "";

        const hits = AspectCalculator.buildMatrix(bodies, aspects);

        const thead = document.createElement("thead");
        const hrow = document.createElement("tr");
        hrow.appendChild(Object.assign(document.createElement("th"), { textContent: "" }));
        for (const b of bodies) {
          const th = document.createElement("th");
          th.className = "aspectCell";
          th.innerHTML = `<span class="mono">${b.glyph}</span><div class="small muted">${b.key}</div>`;
          hrow.appendChild(th);
        }
        thead.appendChild(hrow);
        tbl.appendChild(thead);

        const tbody = document.createElement("tbody");
        for (let i=0;i<bodies.length;i++) {
          const tr = document.createElement("tr");
          const rowH = document.createElement("th");
          rowH.className = "aspectCell";
          rowH.innerHTML = `<span class="mono">${bodies[i].glyph}</span><div class="small muted">${bodies[i].key}</div>`;
          tr.appendChild(rowH);

          for (let j=0;j<bodies.length;j++) {
            const td = document.createElement("td");
            td.className = "aspectCell";
            if (i === j) {
              td.textContent = "—";
              td.classList.add("muted");
            } else {
              const hit = hits[i][j];
              if (hit) {
                td.innerHTML = `<span class="mono">${hit.aspect.sym}</span> <span class="mono">${orbToText(hit.orb)}</span>`;
              } else {
                td.textContent = "";
              }
            }
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        tbl.appendChild(tbody);
      }
    }

    // ===== Boot =====
    const app = new App();
    await app.init();
  </script>
</body>
</html>
